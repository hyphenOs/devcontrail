diff --git a/third_party/thrift-0.8.0/compiler/cpp/src/generate/t_cpp_generator.cc b/third_party/thrift-0.8.0/compiler/cpp/src/generate/t_cpp_generator.cc
index 5291875..1f3376d 100755
--- a/third_party/thrift-0.8.0/compiler/cpp/src/generate/t_cpp_generator.cc
+++ b/third_party/thrift-0.8.0/compiler/cpp/src/generate/t_cpp_generator.cc
@@ -69,6 +69,9 @@ class t_cpp_generator : public t_oop_generator {
     iter = parsed_options.find("templates");
     gen_templates_ = (iter != parsed_options.end());
 
+    iter = parsed_options.find("async");
+    gen_async_ = (iter != parsed_options.end());
+
     out_dir_base_ = "gen-cpp";
   }
 
@@ -100,7 +103,7 @@ class t_cpp_generator : public t_oop_generator {
   void print_const_value(std::ofstream& out, std::string name, t_type* type, t_const_value* value);
   std::string render_const_value(std::ofstream& out, std::string name, t_type* type, t_const_value* value);
 
-  void generate_struct_definition    (std::ofstream& out, t_struct* tstruct, bool is_exception=false, bool pointers=false, bool read=true, bool write=true);
+  void generate_struct_definition    (std::ofstream& out, t_struct* tstruct, bool is_exception=false, bool pointers=false, bool read=true, bool write=true, bool swap=false, bool typedefs=false);
   void generate_struct_fingerprint   (std::ofstream& out, t_struct* tstruct, bool is_definition);
   void generate_struct_reader        (std::ofstream& out, t_struct* tstruct, bool pointers=false);
   void generate_struct_writer        (std::ofstream& out, t_struct* tstruct, bool pointers=false);
@@ -124,6 +127,14 @@ class t_cpp_generator : public t_oop_generator {
   void generate_service_async_skeleton (t_service* tservice);
 
   /**
+   * Service-level async generation functions
+   */
+	void generate_async_interface(t_service* tservice);
+	void generate_async_client(t_service* tservice);
+  void generate_async_processor (t_service* tservice);
+  void generate_async_process_function  (t_service* tservice, t_function* tfunction);
+
+  /**
    * Serialization constructs
    */
 
@@ -199,6 +210,8 @@ class t_cpp_generator : public t_oop_generator {
   std::string argument_list(t_struct* tstruct, bool name_params=true, bool start_comma=false);
   std::string type_to_enum(t_type* ttype);
   std::string local_reflection_name(const char*, t_type* ttype, bool external=false);
+  std::string async_function_signature(t_service* tservice, t_function* tfunction, std::string method_prefix="", std::string return_prefix="", bool name_params=true);
+  std::string async_recv_signature(t_service* tservice, t_function* tfunction, std::string prefix="", bool name_params=true);
 
   void generate_enum_constant_list(std::ofstream& f,
                                    const vector<t_enum_value*>& constants,
@@ -242,6 +255,11 @@ class t_cpp_generator : public t_oop_generator {
   bool gen_dense_;
 
   /**
+   * True if we should generate asynchronous callback code.
+   */
+  bool gen_async_;
+
+  /**
    * True if we should generate templatized reader/writer methods.
    */
   bool gen_templates_;
@@ -342,6 +360,15 @@ void t_cpp_generator::init_generator() {
     "#include <protocol/TProtocol.h>" << endl <<
     "#include <transport/TTransport.h>" << endl <<
     endl;
+	if (gen_async_) {
+		f_types_ <<
+			"#include <boost/bind.hpp>" << endl <<
+		        "#include <boost/function.hpp>" << endl <<
+                        "#include <async/TAsync.h>" << endl <<
+                        "#include <async/TFuture.h>" << endl <<
+                        "#include <concurrency/Mutex.h>" << endl <<
+			endl;
+	}
 
   // Include other Thrift includes
   const vector<t_program*>& includes = program_->get_includes();
@@ -769,7 +796,9 @@ void t_cpp_generator::generate_struct_definition(ofstream& out,
                                                  bool is_exception,
                                                  bool pointers,
                                                  bool read,
-                                                 bool write) {
+                                                 bool write,
+                                                 bool swap,
+                                                 bool typedefs) {
   string extends = "";
   if (is_exception) {
     extends = " : public ::apache::thrift::TException";
@@ -889,6 +918,36 @@ void t_cpp_generator::generate_struct_definition(ofstream& out,
       indent() << "virtual ~" << tstruct->get_name() << "() throw() {}" << endl << endl;
   }
 
+  if (typedefs) {
+    // Add typedef so that we can use as types:
+    // - Calculator_add_result::success_t
+    // - Calculator_add_result::failure_t
+    // - Calculator_add_result::success_nonvoid_t (which replaces void with bool)
+    // - Calculator_add_result::success_constref_t (which changes to const& for complex types)
+    // This is useful when templatizing over result objects.
+
+    map<string, t_type*> typedef_types;
+
+    for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
+      t_type* t = get_true_type((*m_iter)->get_type());
+      typedef_types[(*m_iter)->get_name()] = t;
+    }
+
+    map<string, string> typedef_names;
+
+    typedef_names["success_t"] = typedef_types["success"] ? type_name(typedef_types["success"]) : "void";
+    typedef_names["failure_t"] = typedef_types["failure"] ? type_name(typedef_types["failure"]) : "void";
+    typedef_names["success_nonvoid_t"] = typedef_names["success_t"] != "void" ? typedef_names["success_t"] : "bool";
+    typedef_names["success_constref_t"] = (typedef_types["success"] && is_complex_type(typedef_types["success"]))
+      ? "const " + type_name(typedef_types["success"]) + "&"
+      : typedef_names["success_t"];
+    typedef_names["success_constref_nonvoid_t"] = typedef_names["success_constref_t"] != "void" ? typedef_names["success_constref_t"] : "bool";
+
+    for (map<string, string>::const_iterator i = typedef_names.begin(); i != typedef_names.end(); ++i) {
+      indent(out) << "typedef " << i->second << " " << i->first << ";" << endl;
+    }
+  }
+
   // Pointer to this structure's reflection local typespec.
   if (gen_dense_) {
     indent(out) <<
@@ -942,6 +1001,8 @@ void t_cpp_generator::generate_struct_definition(ofstream& out,
       (members.size() > 0 ? "rhs" : "/* rhs */") << ") const" << endl;
     scope_up(out);
     for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
+			if (gen_async_ && (*m_iter)->get_name() == "failure")
+				continue;
       // Most existing Thrift code does not use isset or optional/required,
       // so we treat "default" fields as required.
       if ((*m_iter)->get_req() != t_field::T_OPTIONAL) {
@@ -1569,6 +1630,12 @@ void t_cpp_generator::generate_service(t_service* tservice) {
   generate_service_multiface(tservice);
   generate_service_skeleton(tservice);
 
+  if (gen_async_) {
+    generate_async_interface(tservice);
+    generate_async_client(tservice);
+    generate_async_processor(tservice);
+  }
+
   // Generate all the cob components
   if (gen_cob_style_) {
     generate_service_interface(tservice, "CobCl");
@@ -1794,6 +1861,89 @@ void t_cpp_generator::generate_service_interface_factory(t_service* tservice,
 }
 
 /**
+ * Generates a service asynchronous callback interface definition.
+ *
+ * @param tservice The service to generate a header definition for
+ */
+void t_cpp_generator::generate_async_interface(t_service* tservice) {
+
+  string extends = "";
+  if (tservice->get_extends() != NULL) {
+    extends = " : virtual public " + type_name(tservice->get_extends()) + "AsyncIf";
+  }
+  f_header_ <<
+    "class " << service_name_ << "AsyncIf" << extends << " {" << endl <<
+    " public:" << endl;
+  indent_up();
+
+  // First, generate all the controller typedefs outside the class
+
+  vector<t_function*> functions = tservice->get_functions();
+  vector<t_function*>::iterator f_iter;
+  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
+    t_function* tfunction = *f_iter;
+    if (!tfunction->is_oneway()) {
+      // t_type* ttype = tfunction->get_returntype();
+      f_header_ << indent() << "typedef apache::thrift::async::TSharedPromise<" + tservice->get_name() + "_" + tfunction->get_name() + "_result> " + tfunction->get_name() + "_shared_promise_t;" << endl;
+      f_header_ << indent() << "typedef apache::thrift::async::TSharedFuture<" + tservice->get_name() + "_" + tfunction->get_name() + "_result> " + tfunction->get_name() + "_shared_future_t;" << endl;
+    }
+  }
+  
+  f_header_ << endl;
+  
+  // Generate constructors and destructors
+
+  f_header_ <<
+    indent() << "virtual ~" << service_name_ << "AsyncIf() {}" << endl;
+
+  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
+    f_header_ <<
+      indent() << "virtual " << async_function_signature(tservice, *f_iter) << " = 0;" << endl;
+  }
+
+  // Callback result typedefs and convenience functions
+  f_header_ << endl;
+  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
+    if (!(*f_iter)->is_oneway()) {
+      string resultname = (*f_iter)->get_name() + "_result";
+      indent(f_header_) << 
+	"typedef " << tservice->get_name() << "_" << resultname << " " << resultname << ";" << endl;
+      vector<t_field*>::iterator ff_iter;
+      vector<t_field*> results = (*f_iter)->get_xceptions()->get_members();
+      
+      t_field success((*f_iter)->get_returntype(), "success", 0);
+      if (!(*f_iter)->get_returntype()->is_void()) {
+	results.insert(results.begin(), &success);
+      }
+      t_struct exc(NULL, "apache::thrift::TApplicationException");
+      t_field failure(&exc, "failure", -1337); // FIXME: failure field id
+      results.insert(results.begin(), &failure);
+      for (ff_iter = results.begin(); ff_iter != results.end(); ++ff_iter) {
+	indent(f_header_) <<
+	  "static " << resultname << " " << (*f_iter)->get_name() << "_" << (*ff_iter)->get_name() << "(" << type_name((*ff_iter)->get_type()) << " " << (*ff_iter)->get_name() << ");" << endl;
+	// Implementation
+	indent_down();
+	f_service_ <<
+	  indent() << service_name_ << "AsyncIf::" << resultname << " " << service_name_ << "AsyncIf::" << (*f_iter)->get_name() << "_" << (*ff_iter)->get_name() << "(" << type_name((*ff_iter)->get_type()) << " " << (*ff_iter)->get_name() << ")" << endl;
+	scope_up(f_service_);
+	f_service_ <<
+	  indent() << resultname << " result;" << endl <<
+	  indent() << "result." << (*ff_iter)->get_name() << " = " << (*ff_iter)->get_name() << ";" << endl <<
+	  indent() << "result.__isset." << (*ff_iter)->get_name() << " = true;" << endl <<
+	  indent() << "return result;" << endl;
+	scope_down(f_service_);
+	f_service_ << endl;
+	indent_up();
+      }
+    }
+  }
+  
+  indent_down();
+  f_header_ <<
+    "};" << endl << endl;
+}
+
+/**
  * Generates a null implementation of the service.
  *
  * @param tservice The service to generate a header definition for
@@ -1830,13 +1980,13 @@ void t_cpp_generator::generate_service_null(t_service* tservice, string style) {
     } else if (style == "CobSv") {
       if (returntype->is_void()) {
         f_header_ << indent() << "return cob();" << endl;
-    } else {
-      t_field returnfield(returntype, "_return");
-      f_header_ <<
-        indent() << declare_field(&returnfield, true) << endl <<
-        indent() << "return cob(_return);" << endl;
-    }
-
+      } else {
+	t_field returnfield(returntype, "_return");
+	f_header_ <<
+	  indent() << declare_field(&returnfield, true) << endl <<
+	  indent() << "return cob(_return);" << endl;
+      }
+      
     } else {
       throw "UNKNOWN STYLE";
     }
@@ -2080,6 +2230,316 @@ void t_cpp_generator::generate_service_multiface(t_service* tservice) {
 }
 
 /**
+ * Generates a service async client definition.
+ *
+ * @param tservice The service to generate an async client for.
+ */
+void t_cpp_generator::generate_async_client(t_service* tservice) {
+  string extends = "";
+  string extends_client = "";
+	string extends_processor = "";
+  if (tservice->get_extends() != NULL) {
+    extends = type_name(tservice->get_extends());
+    extends_client = ", public " + extends + "AsyncClient";
+  }
+	else {
+		extends_processor = ", public apache::thrift::TProcessor";
+	}
+
+  // Generate the header portion
+  f_header_ <<
+    "class " << service_name_ << "AsyncClient : " <<
+    "virtual public " << service_name_ << "AsyncIf" <<
+    extends_client << extends_processor << " {" << endl <<
+    " public:" << endl;
+
+  indent_up();
+  f_header_ <<
+    indent() << service_name_ << "AsyncClient(boost::shared_ptr<apache::thrift::transport::TTransport> ot, boost::shared_ptr<apache::thrift::protocol::TProtocolFactory> opf) :" << endl;
+  if (extends.empty()) {
+    f_header_ <<
+      indent() << "  potransport_(ot)," << endl <<
+      indent() << "  poprotfact_(opf)," << endl <<
+      indent() << "  request_counter_(0) {" << endl <<
+      indent() << "  otransport_ = ot.get();" << endl <<
+      indent() << "  oprotfact_ = opf.get();" << endl <<
+      indent() << "}" << endl;
+  } else {
+    f_header_ <<
+      indent() << "  " << extends << "AsyncClient(ot, opf) {}" << endl;
+  }
+
+  // Generate getters for the transport and protocol factory.
+  f_header_ <<
+    indent() << "boost::shared_ptr<apache::thrift::transport::TTransport> getOutputTransport() {" << endl <<
+    indent() << "  return potransport_;" << endl <<
+    indent() << "}" << endl;
+  f_header_ <<
+    indent() << "boost::shared_ptr<apache::thrift::protocol::TProtocolFactory> getOutputProtocolFactory() {" << endl <<
+    indent() << "  return poprotfact_;" << endl <<
+    indent() << "}" << endl;
+
+  vector<t_function*> functions = tservice->get_functions();
+  vector<t_function*>::const_iterator f_iter;
+  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
+    t_function send_function(g_type_void,
+                             string("send_") + (*f_iter)->get_name(),
+                             (*f_iter)->get_arglist());
+    indent(f_header_) << async_function_signature(tservice, *f_iter) << ";" << endl;
+    indent(f_header_) << function_signature(&send_function, "") << ";" << endl;
+    if (!(*f_iter)->is_oneway()) {
+      //t_struct noargs(program_);
+      //t_function recv_function((*f_iter)->get_returntype(),
+      //                         string("recv_") + (*f_iter)->get_name(),
+      //                         &noargs);
+      //indent(f_header_) << function_signature(&recv_function, "") << ";" << endl;
+			//indent(f_header_) << "void " << "recv_" << (*f_iter)->get_name() << "(apache::thrift::protocol::TProtocol* iprot, std::string fname, apache::thrift::protocol::TMessageType mtype);" << endl;
+			indent(f_header_) << async_recv_signature(tservice, *f_iter) << ";" << endl;
+    }
+  }
+  if (extends.empty()) {
+		f_header_ <<
+			indent() << "bool abort(int32_t request_id) {" << endl <<
+                        indent() << "apache::thrift::concurrency::Guard g(mutex_);" << endl <<
+			indent() << "  return requests_.erase(request_id) != 0;" << endl <<
+			indent() << "}" << endl;
+  }
+  indent(f_header_) << "bool process(boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, void* connectionContext);" << endl;
+
+  indent_down();
+
+  if (extends.empty()) {
+    f_header_ <<
+      " protected:" << endl;
+    indent_up();
+    f_header_ <<
+      indent() << "boost::shared_ptr<apache::thrift::transport::TTransport> potransport_;" << endl <<
+      indent() << "boost::shared_ptr<apache::thrift::protocol::TProtocolFactory> poprotfact_;"  << endl <<
+      indent() << "apache::thrift::transport::TTransport* otransport_;" << endl <<
+      indent() << "apache::thrift::protocol::TProtocolFactory* oprotfact_;"  << endl <<
+      indent() << "typedef std::map<int32_t, boost::function<void (boost::shared_ptr<apache::thrift::protocol::TProtocol> prot, std::string fname, apache::thrift::protocol::TMessageType mtype)> > request_map_t;" << endl <<
+      indent() << "request_map_t requests_;" << endl <<
+      indent() << "int32_t request_counter_;" << endl <<
+      indent() << "apache::thrift::concurrency::Mutex mutex_;";
+    indent_down();
+  }
+
+  f_header_ <<
+    "};" << endl <<
+    endl;
+
+  string scope = service_name_ + "AsyncClient::";
+  string typedef_scope = service_name_ + "AsyncIf::";
+
+  // Generate async client method implementations
+  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
+    string funname = (*f_iter)->get_name();
+
+    // Open function
+    indent(f_service_) <<
+      async_function_signature(tservice, *f_iter, scope, typedef_scope) << endl;
+    scope_up(f_service_);
+    indent(f_service_) <<
+      "send_" << funname << "(";
+
+    // Get the struct of function call params
+    t_struct* arg_struct = (*f_iter)->get_arglist();
+
+    // Declare the function arguments
+    const vector<t_field*>& fields = arg_struct->get_members();
+    vector<t_field*>::const_iterator fld_iter;
+    bool first = true;
+    for (fld_iter = fields.begin(); fld_iter != fields.end(); ++fld_iter) {
+      if (first) {
+        first = false;
+      } else {
+        f_service_ << ", ";
+      }
+      f_service_ << (*fld_iter)->get_name();
+    }
+    f_service_ << ");" << endl;
+
+    if (!(*f_iter)->is_oneway()) {
+      string promise_type = (*f_iter)->get_name() + "_shared_promise_t";
+      f_service_ << indent() << promise_type << " promise;" << endl;
+      f_service_ << indent() << "apache::thrift::concurrency::Guard g(mutex_);" << endl;
+      f_service_ << indent() << "requests_[request_counter_] = boost::bind(&" << scope << "recv_" << funname << ", this, _1 /* piprot */, _2 /* fname */, _3 /* mtype */, promise);" << endl;
+      f_service_ << indent() << "return promise;" << endl;
+			/*
+      f_service_ << indent();
+      if (!(*f_iter)->get_returntype()->is_void()) {
+        if (is_complex_type((*f_iter)->get_returntype())) {
+          f_service_ << "recv_" << funname << "(_return);" << endl;
+        } else {
+          f_service_ << "return recv_" << funname << "();" << endl;
+        }
+      } else {
+        f_service_ <<
+          "recv_" << funname << "();" << endl;
+      }
+			*/
+    }
+		else {
+			f_service_ << indent() << "return; // one-way" << endl;
+		}
+    scope_down(f_service_);
+    f_service_ << endl;
+
+    // Function for sending
+    t_function send_function(g_type_void,
+                             string("send_") + (*f_iter)->get_name(),
+                             (*f_iter)->get_arglist());
+
+    // Open the send function
+    indent(f_service_) <<
+      function_signature(&send_function, "", scope) << endl;
+    scope_up(f_service_);
+
+    // Function arguments and results
+    string argsname = tservice->get_name() + "_" + (*f_iter)->get_name() + "_pargs";
+    string resultname = tservice->get_name() + "_" + (*f_iter)->get_name() + "_result";
+
+    // Serialize the request
+    f_service_ <<
+			indent() << "boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot = oprotfact_->getProtocol(potransport_);" << endl <<
+			indent() << "apache::thrift::protocol::TProtocol* oprot = poprot.get();" << endl <<
+      indent() << "apache::thrift::concurrency::Guard g(mutex_); // for oprot and request_counter_" << endl <<
+      indent() << "if (++request_counter_ < 0)" << endl <<
+      indent() << "  request_counter_ = 1;" << endl <<
+      indent() << "int32_t cseqid = request_counter_;" << endl <<
+      indent() << "oprot->writeMessageBegin(\"" << (*f_iter)->get_name() << "\", apache::thrift::protocol::T_CALL, cseqid);" << endl <<
+      endl <<
+      indent() << argsname << " args;" << endl;
+
+    for (fld_iter = fields.begin(); fld_iter != fields.end(); ++fld_iter) {
+      f_service_ <<
+        indent() << "args." << (*fld_iter)->get_name() << " = &" << (*fld_iter)->get_name() << ";" << endl;
+    }
+
+    f_service_ <<
+      indent() << "args.write(oprot);" << endl <<
+      endl <<
+      indent() << "oprot->writeMessageEnd();" << endl <<
+      indent() << "oprot->getTransport()->flush();" << endl <<
+      indent() << "oprot->getTransport()->writeEnd();" << endl;
+
+    scope_down(f_service_);
+    f_service_ << endl;
+
+    // Generate recv function only if not an oneway function
+    if (!(*f_iter)->is_oneway()) {
+      t_struct noargs(program_);
+      t_function recv_function((*f_iter)->get_returntype(),
+                               string("recv_") + (*f_iter)->get_name(),
+                               &noargs);
+
+      // Open function
+			indent(f_service_) << async_recv_signature(tservice, *f_iter, scope) << endl;
+      scope_up(f_service_);
+
+      f_service_ <<
+        endl <<
+        indent() << "if (mtype == apache::thrift::protocol::T_EXCEPTION) {" << endl <<
+        indent() << "  apache::thrift::TApplicationException x;" << endl <<
+        indent() << "  x.read(iprot.get());" << endl <<
+        indent() << "  iprot->readMessageEnd();" << endl <<
+        indent() << "  iprot->getTransport()->readEnd();" << endl <<
+        indent() << "  promise.errback(" << (*f_iter)->get_name() << "_failure(x));" << endl <<
+        indent() << "  return;" << endl <<
+        indent() << "}" << endl <<
+        indent() << "if (mtype != apache::thrift::protocol::T_REPLY) {" << endl <<
+        indent() << "  iprot->skip(apache::thrift::protocol::T_STRUCT);" << endl <<
+        indent() << "  iprot->readMessageEnd();" << endl <<
+        indent() << "  iprot->getTransport()->readEnd();" << endl <<
+        indent() << "  promise.errback(" << (*f_iter)->get_name() << "_failure(apache::thrift::TApplicationException(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE)));" << endl <<
+				indent() << "  return;" << endl <<
+        indent() << "}" << endl <<
+        indent() << "if (fname.compare(\"" << (*f_iter)->get_name() << "\") != 0) {" << endl <<
+        indent() << "  iprot->skip(apache::thrift::protocol::T_STRUCT);" << endl <<
+        indent() << "  iprot->readMessageEnd();" << endl <<
+        indent() << "  iprot->getTransport()->readEnd();" << endl <<
+        indent() << "  promise.errback(" << (*f_iter)->get_name() << "_failure(apache::thrift::TApplicationException(apache::thrift::TApplicationException::WRONG_METHOD_NAME)));" << endl <<
+				indent() << "  return;" << endl <<
+        indent() << "}" << endl;
+
+      if (!(*f_iter)->get_returntype()->is_void() &&
+          !is_complex_type((*f_iter)->get_returntype())) {
+        t_field returnfield((*f_iter)->get_returntype(), "_return");
+        f_service_ <<
+          indent() << declare_field(&returnfield) << endl;
+      }
+
+      f_service_ <<
+        indent() << resultname << " result;" << endl;
+
+      f_service_ <<
+        indent() << "result.read(iprot.get());" << endl <<
+        indent() << "iprot->readMessageEnd();" << endl <<
+        indent() << "iprot->getTransport()->readEnd();" << endl <<
+        endl;
+
+      // Careful, only look for _result if not a void function
+      if (!(*f_iter)->get_returntype()->is_void()) {
+				f_service_ <<
+					indent() << "if (result.__isset.success) {" << endl <<
+					indent() << "  promise.callback(result.success);" << endl <<
+					indent() << "  return;" << endl <<
+					indent() << "}" << endl;
+      }
+
+			// Handle failure
+			// FIXME: deprecated! failure is sent as exception
+			f_service_ <<
+				indent() << "if (result.__isset.failure) {" << endl <<
+				indent() << "  promise.errback(result);" << endl <<
+				indent() << "  return;" << endl <<
+				indent() << "}" << endl;
+
+			// Handle exception
+      t_struct* xs = (*f_iter)->get_xceptions();
+      const std::vector<t_field*>& xceptions = xs->get_members();
+      vector<t_field*>::const_iterator x_iter;
+      for (x_iter = xceptions.begin(); x_iter != xceptions.end(); ++x_iter) {
+        f_service_ <<
+          indent() << "if (result.__isset." << (*x_iter)->get_name() << ") {" << endl <<
+          indent() << "  promise.errback(result);" << endl <<
+          indent() << "  return;" << endl <<
+          indent() << "}" << endl;
+      }
+
+      // We only get here if we are a void function
+      if ((*f_iter)->get_returntype()->is_void()) {
+        indent(f_service_) << "promise.callback();" << endl;
+      } else {
+        f_service_ <<
+	  indent() << "  promise.errback(" << (*f_iter)->get_name() << "_failure(apache::thrift::TApplicationException(apache::thrift::TApplicationException::MISSING_RESULT, \"" << (*f_iter)->get_name() << " failed: unknown result\")));" <<
+	  indent() << "  return;" << endl;
+      }
+
+      // Close function
+      scope_down(f_service_);
+      f_service_ << endl;
+    }
+  }
+  indent(f_service_) << "bool " << scope << "process(boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, void* connectionContext)" << endl;
+  scope_up(f_service_);
+	f_service_ <<
+		indent() << "std::string fname;" << endl <<
+		indent() << "apache::thrift::protocol::TMessageType mtype;" << endl <<
+		indent() << "int32_t rseqid;" << endl <<
+		endl <<
+		indent() << "piprot->readMessageBegin(fname, mtype, rseqid);" << endl <<
+	        indent() << "apache::thrift::concurrency::Guard g(mutex_);" << endl <<
+		indent() << "request_map_t::iterator it = requests_.find(rseqid);" << endl <<
+		indent() << "if (it == requests_.end()) return false;" << endl <<
+	        indent() << "it->second(piprot, fname, mtype); /* Invoke user method */" << endl <<
+		indent() << "requests_.erase(it);" << endl <<
+		indent() << "return true;" << endl;
+
+  scope_down(f_service_);
+}
+
+/**
  * Generates a service client definition.
  *
  * @param tservice The service to generate a server for.
@@ -2696,7 +3156,7 @@ void ProcessorGenerator::generate_class_definition() {
   f_header_ <<
     indent() << "boost::shared_ptr<" << if_name_ << "> iface_;" << endl;
   f_header_ <<
-    indent() << "virtual " << ret_type_ << "process_fn(" << finish_cob_ << "apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid" << call_context_ << ");" << endl;
+    indent() << "virtual " << ret_type_ << "process_fn(" << finish_cob_ << " ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid" << call_context_ << ");" << endl;
   indent_down();
 
   // Process function declarations
@@ -2706,12 +3166,12 @@ void ProcessorGenerator::generate_class_definition() {
   f_header_ <<
     indent() << "std::map<std::string, void (" <<
     class_name_ << "::*)(" << finish_cob_decl_ <<
-    "int32_t, apache::thrift::protocol::TProtocol*, " <<
-    "apache::thrift::protocol::TProtocol*" << call_context_decl_ <<
+    "int32_t, ::apache::thrift::protocol::TProtocol*, " <<
+    " ::apache::thrift::protocol::TProtocol*" << call_context_decl_ <<
     ")> processMap_;" << endl;
   for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
     indent(f_header_) <<
-      "void process_" << (*f_iter)->get_name() << "(" << finish_cob_ << "int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot" << call_context_ << ");" << endl;
+      "void process_" << (*f_iter)->get_name() << "(" << finish_cob_ << "int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot" << call_context_ << ");" << endl;
     if (generator_->gen_templates_) {
       indent(f_header_) <<
         "void process_" << (*f_iter)->get_name() << "(" << finish_cob_ <<
@@ -2738,8 +3198,8 @@ void ProcessorGenerator::generate_class_definition() {
       f_header_ <<
         indent() << "void throw_" << (*f_iter)->get_name() <<
         "(std::tr1::function<void(bool ok)> cob, int32_t seqid, " <<
-        "apache::thrift::protocol::TProtocol* oprot, void* ctx, " <<
-        "apache::thrift::TDelayedException* _throw);" << endl;
+        " ::apache::thrift::protocol::TProtocol* oprot, void* ctx, " <<
+        " ::apache::thrift::TDelayedException* _throw);" << endl;
       if (generator_->gen_templates_) {
         f_header_ <<
           indent() << "void throw_" << (*f_iter)->get_name() <<
@@ -2783,7 +3243,7 @@ void ProcessorGenerator::generate_class_definition() {
     declare_map <<
     indent() << "}" << endl <<
     endl <<
-    indent() << "virtual " << ret_type_ << "process(" << finish_cob_ << "boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot" << call_context_ << ");" << endl <<
+    indent() << "virtual " << ret_type_ << "process(" << finish_cob_ << "boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot" << call_context_ << ");" << endl <<
     indent() << "virtual ~" << class_name_ <<
     "() {}" << endl;
   indent_down();
@@ -2802,7 +3262,7 @@ void ProcessorGenerator::generate_class_definition() {
     // template parameter here.
     f_header_ <<
       "typedef " << class_name_ <<
-      "<apache::thrift::protocol::TDummyProtocol> " <<
+      "< ::apache::thrift::protocol::TDummyProtocol> " <<
       service_name_ << pstyle_ << "Processor;" << endl << endl;
   }
 }
@@ -2812,8 +3272,8 @@ void ProcessorGenerator::generate_process() {
     template_header_ <<
     ret_type_ << class_name_ <<
     template_suffix_ << "::process(" << finish_cob_ <<
-    "boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, " <<
-    "boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot" <<
+    "boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot, " <<
+    "boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot" <<
     call_context_ << ") {" << endl;
   indent_up();
 
@@ -2855,8 +3315,8 @@ void ProcessorGenerator::generate_process_fn() {
     template_header_ <<
     ret_type_ << class_name_ <<
     template_suffix_ << "::process_fn(" << finish_cob_ <<
-    "apache::thrift::protocol::TProtocol* iprot, " <<
-    "apache::thrift::protocol::TProtocol* oprot, " <<
+    " ::apache::thrift::protocol::TProtocol* iprot, " <<
+    " ::apache::thrift::protocol::TProtocol* oprot, " <<
     "std::string& fname, int32_t seqid" << call_context_ << ") {" << endl;
   indent_up();
 
@@ -2864,13 +3324,13 @@ void ProcessorGenerator::generate_process_fn() {
   f_out_ <<
     indent() << typename_str_ << "std::map<std::string, void (" <<
     class_name_ << "::*)(" << finish_cob_decl_ <<
-    "int32_t, apache::thrift::protocol::TProtocol*, " <<
-    "apache::thrift::protocol::TProtocol*" << call_context_decl_ << ")>::iterator pfn;" << endl <<
+    "int32_t, ::apache::thrift::protocol::TProtocol*, " <<
+    " ::apache::thrift::protocol::TProtocol*" << call_context_decl_ << ")>::iterator pfn;" << endl <<
     indent() << "pfn = processMap_.find(fname);" << endl <<
     indent() << "if (pfn == processMap_.end()) {" << endl;
   if (extends_.empty()) {
     f_out_ <<
-      indent() << "  iprot->skip(apache::thrift::protocol::T_STRUCT);" << endl <<
+      indent() << "  iprot->skip(::apache::thrift::protocol::T_STRUCT);" << endl <<
       indent() << "  iprot->readMessageEnd();" << endl <<
       indent() << "  iprot->getTransport()->readEnd();" << endl <<
       indent() << "  ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, \"Invalid method name: '\"+fname+\"'\");" << endl <<
@@ -2998,6 +3458,177 @@ void t_cpp_generator::generate_service_processor(t_service* tservice,
 }
 
 /**
+ * Generates a service server definition.
+ *
+ * @param tservice The service to generate a server for.
+ */
+void t_cpp_generator::generate_async_processor(t_service* tservice) {
+  // Generate the dispatch methods
+  vector<t_function*> functions = tservice->get_functions();
+  vector<t_function*>::iterator f_iter;
+
+  string extends = "";
+  string extends_processor = "";
+  if (tservice->get_extends() != NULL) {
+    extends = type_name(tservice->get_extends());
+    extends_processor = ", public " + extends + "AsyncProcessor";
+  }
+
+  // Generate the header portion
+  f_header_ <<
+    "class " << service_name_ << "AsyncProcessor : " <<
+    "virtual public apache::thrift::TProcessor" <<
+    extends_processor << " {" << endl;
+
+  // Protected data members
+  f_header_ <<
+    " protected:" << endl;
+  indent_up();
+  f_header_ <<
+    indent() << "boost::shared_ptr<" << service_name_ << "AsyncIf> iface_;" << endl;
+  f_header_ <<
+		  indent() << "virtual bool process_fn(boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, std::string& fname, int32_t seqid);" << endl;
+
+  indent_down();
+
+  // Process function declarations
+  f_header_ <<
+    " private:" << endl;
+  indent_up();
+  f_header_ <<
+    indent() << "std::map<std::string, void (" << service_name_ << "AsyncProcessor::*)(int32_t, boost::shared_ptr<apache::thrift::protocol::TProtocol>, boost::shared_ptr<apache::thrift::protocol::TProtocol>)> processMap_;" << endl;
+  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
+    indent(f_header_) <<
+      "void process_" << (*f_iter)->get_name() << "(int32_t seqid, boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot);" << endl;
+		if (!(*f_iter)->is_oneway()) {
+			if (!(*f_iter)->get_returntype()->is_void()) {
+				indent(f_header_) <<
+					"void success_" << (*f_iter)->get_name() << "(int32_t seqid, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, " << type_name((*f_iter)->get_returntype()) << " value);" << endl;
+			}
+			else {
+				indent(f_header_) <<
+					"void success_" << (*f_iter)->get_name() << "(int32_t seqid, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot);" << endl;
+			}
+			indent(f_header_) <<
+				"void reply_" << (*f_iter)->get_name() << "(int32_t seqid, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, " << service_name_ << "_" << (*f_iter)->get_name() << "_result result);" << endl;
+		}
+	}
+  indent_down();
+
+  indent_up();
+  string declare_map = "";
+  indent_up();
+
+  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
+    declare_map += indent();
+    declare_map += "processMap_[\"";
+    declare_map += (*f_iter)->get_name();
+    declare_map += "\"] = &";
+    declare_map += service_name_;
+    declare_map += "AsyncProcessor::process_";
+    declare_map += (*f_iter)->get_name();
+    declare_map += ";\n";
+  }
+  indent_down();
+
+  f_header_ <<
+    " public:" << endl <<
+		// Constructor
+    indent() << service_name_ << "AsyncProcessor(boost::shared_ptr<" << service_name_ << "AsyncIf> iface) :" << endl;
+  if (extends.empty()) {
+    f_header_ <<
+      indent() << "  iface_(iface) {" << endl;
+  } else {
+    f_header_ <<
+      indent() << "  " << extends << "AsyncProcessor(iface)," << endl <<
+      indent() << "  iface_(iface) {" << endl;
+  }
+  f_header_ <<
+    declare_map <<
+    indent() << "}" << endl <<
+    endl <<
+    indent() << "virtual bool process(boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, void* connectionContext);" << endl <<
+    indent() << "virtual ~" << service_name_ << "AsyncProcessor() {}" << endl;
+  indent_down();
+  f_header_ <<
+    "};" << endl << endl;
+
+  // Generate the server implementation
+  f_service_ <<
+    "bool " << service_name_ << "AsyncProcessor::process(boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, void* connectionContext) {" << endl;
+  indent_up();
+
+  f_service_ <<
+    endl <<
+    indent() << "std::string fname;" << endl <<
+    indent() << "apache::thrift::protocol::TMessageType mtype;" << endl <<
+    indent() << "int32_t seqid;" << endl <<
+    endl <<
+    indent() << "piprot->readMessageBegin(fname, mtype, seqid);" << endl <<
+    endl <<
+    indent() << "if (mtype != apache::thrift::protocol::T_CALL && mtype != apache::thrift::protocol::T_ONEWAY) {" << endl <<
+    indent() << "  piprot->skip(apache::thrift::protocol::T_STRUCT);" << endl <<
+    indent() << "  piprot->readMessageEnd();" << endl <<
+    indent() << "  piprot->getTransport()->readEnd();" << endl <<
+    indent() << "  apache::thrift::TApplicationException x(apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);" << endl <<
+    indent() << "  poprot->writeMessageBegin(fname, apache::thrift::protocol::T_EXCEPTION, seqid);" << endl <<
+    indent() << "  x.write(poprot.get());" << endl <<
+    indent() << "  poprot->writeMessageEnd();" << endl <<
+    indent() << "  poprot->getTransport()->flush();" << endl <<
+    indent() << "  poprot->getTransport()->writeEnd();" << endl <<
+    indent() << "  return true;" << endl <<
+    indent() << "}" << endl <<
+    endl <<
+    indent() << "return process_fn(piprot, poprot, fname, seqid);" <<
+    endl;
+
+  indent_down();
+  f_service_ <<
+    indent() << "}" << endl <<
+    endl;
+
+  f_service_ <<
+    "bool " << service_name_ << "AsyncProcessor::process_fn(boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, std::string& fname, int32_t seqid) {" << endl;
+  indent_up();
+
+  // HOT: member function pointer map
+  f_service_ <<
+    indent() << "std::map<std::string, void (" << service_name_ << "AsyncProcessor::*)(int32_t, boost::shared_ptr<apache::thrift::protocol::TProtocol>, boost::shared_ptr<apache::thrift::protocol::TProtocol>)>::iterator pfn;" << endl <<
+    indent() << "pfn = processMap_.find(fname);" << endl <<
+    indent() << "if (pfn == processMap_.end()) {" << endl;
+  if (extends.empty()) {
+    f_service_ <<
+      indent() << "  piprot->skip(apache::thrift::protocol::T_STRUCT);" << endl <<
+      indent() << "  piprot->readMessageEnd();" << endl <<
+      indent() << "  piprot->getTransport()->readEnd();" << endl <<
+      indent() << "  apache::thrift::TApplicationException x(apache::thrift::TApplicationException::UNKNOWN_METHOD, \"Invalid method name: '\"+fname+\"'\");" << endl <<
+      indent() << "  poprot->writeMessageBegin(fname, apache::thrift::protocol::T_EXCEPTION, seqid);" << endl <<
+      indent() << "  x.write(poprot.get());" << endl <<
+      indent() << "  poprot->writeMessageEnd();" << endl <<
+      indent() << "  poprot->getTransport()->flush();" << endl <<
+      indent() << "  poprot->getTransport()->writeEnd();" << endl <<
+      indent() << "  return true;" << endl;
+  } else {
+    f_service_ <<
+      indent() << "  return " << extends << "AsyncProcessor::process_fn(piprot, poprot, fname, seqid);" << endl;
+  }
+  f_service_ <<
+    indent() << "}" << endl <<
+    indent() << "(this->*(pfn->second))(seqid, piprot, poprot);" << endl <<
+    indent() << "return true;" << endl;
+
+  indent_down();
+  f_service_ <<
+    "}" << endl <<
+    endl;
+
+  // Generate the process subfunctions
+  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
+    generate_async_process_function(tservice, *f_iter);
+  }
+}
+
+/**
  * Generates a struct and helpers for a function.
  *
  * @param tfunction The function
@@ -3016,6 +3647,12 @@ void t_cpp_generator::generate_function_helpers(t_service* tservice,
     result.append(&success);
   }
 
+	t_struct exc(NULL, "apache::thrift::TApplicationException");
+  t_field failure(&exc, "failure", -1337); // FIXME: failure field id
+	if (gen_async_) {
+		result.append(&failure);
+	}
+
   t_struct* xs = tfunction->get_xceptions();
   const vector<t_field*>& fields = xs->get_members();
   vector<t_field*>::const_iterator f_iter;
@@ -3023,7 +3660,7 @@ void t_cpp_generator::generate_function_helpers(t_service* tservice,
     result.append(*f_iter);
   }
 
-  generate_struct_definition(f_header_, &result, false);
+  generate_struct_definition(f_header_, &result, false, false, true, true, false, gen_async_); //if typedefs is true -> compilation error in tests
   generate_struct_reader(out, &result);
   generate_struct_result_writer(out, &result);
 
@@ -3109,7 +3746,7 @@ void t_cpp_generator::generate_process_function(t_service* tservice,
       indent() << "  ctx = this->eventHandler_->getContext(\"" <<
         service_func_name << "\", callContext);" << endl <<
       indent() << "}" << endl <<
-      indent() << "apache::thrift::TProcessorContextFreer freer(" <<
+      indent() << " ::apache::thrift::TProcessorContextFreer freer(" <<
         "this->eventHandler_.get(), ctx, \"" << service_func_name << "\");" <<
         endl << endl <<
       indent() << "if (this->eventHandler_.get() != NULL) {" << endl <<
@@ -3202,10 +3839,10 @@ void t_cpp_generator::generate_process_function(t_service* tservice,
     if (!tfunction->is_oneway()) {
       out <<
         endl <<
-        indent() << "apache::thrift::TApplicationException x(e.what());" <<
+        indent() << " ::apache::thrift::TApplicationException x(e.what());" <<
           endl <<
         indent() << "oprot->writeMessageBegin(\"" << tfunction->get_name() <<
-          "\", apache::thrift::protocol::T_EXCEPTION, seqid);" << endl <<
+          "\", ::apache::thrift::protocol::T_EXCEPTION, seqid);" << endl <<
         indent() << "x.write(oprot);" << endl <<
         indent() << "oprot->writeMessageEnd();" << endl <<
         indent() << "oprot->getTransport()->writeEnd();" << endl <<
@@ -3236,7 +3873,7 @@ void t_cpp_generator::generate_process_function(t_service* tservice,
         service_func_name << "\");" << endl <<
       indent() << "}" << endl << endl <<
       indent() << "oprot->writeMessageBegin(\"" << tfunction->get_name() <<
-        "\", apache::thrift::protocol::T_REPLY, seqid);" << endl <<
+        "\", ::apache::thrift::protocol::T_REPLY, seqid);" << endl <<
       indent() << "result.write(oprot);" << endl <<
       indent() << "oprot->writeMessageEnd();" << endl <<
       indent() << "bytes = oprot->getTransport()->writeEnd();" << endl <<
@@ -3298,7 +3935,7 @@ void t_cpp_generator::generate_process_function(t_service* tservice,
       indent() << "  ctx = this->eventHandler_->getContext(\"" <<
         service_func_name << "\", NULL);" << endl <<
       indent() << "}" << endl <<
-      indent() << "apache::thrift::TProcessorContextFreer freer(" <<
+      indent() << " ::apache::thrift::TProcessorContextFreer freer(" <<
         "this->eventHandler_.get(), ctx, \"" << service_func_name << "\");" <<
         endl << endl <<
       indent() << "try {" << endl;
@@ -3452,7 +4089,7 @@ void t_cpp_generator::generate_process_function(t_service* tservice,
         indent() << "  ctx = this->eventHandler_->getContext(\"" <<
           service_func_name << "\", NULL);" << endl <<
         indent() << "}" << endl <<
-        indent() << "apache::thrift::TProcessorContextFreer freer(" <<
+        indent() << " ::apache::thrift::TProcessorContextFreer freer(" <<
           "this->eventHandler_.get(), ctx, \"" << service_func_name <<
           "\");" << endl << endl <<
         indent() << "if (this->eventHandler_.get() != NULL) {" << endl <<
@@ -3460,7 +4097,7 @@ void t_cpp_generator::generate_process_function(t_service* tservice,
           service_func_name << "\");" << endl <<
         indent() << "}" << endl << endl <<
         indent() << "oprot->writeMessageBegin(\"" << tfunction->get_name() <<
-          "\", apache::thrift::protocol::T_REPLY, seqid);" << endl <<
+          "\", ::apache::thrift::protocol::T_REPLY, seqid);" << endl <<
         indent() << "result.write(oprot);" << endl <<
         indent() << "oprot->writeMessageEnd();" << endl <<
         indent() << "uint32_t bytes = oprot->getTransport()->writeEnd();" <<
@@ -3510,7 +4147,7 @@ void t_cpp_generator::generate_process_function(t_service* tservice,
         indent() << "  ctx = this->eventHandler_->getContext(\"" <<
           service_func_name << "\", NULL);" << endl <<
         indent() << "}" << endl <<
-        indent() << "apache::thrift::TProcessorContextFreer freer(" <<
+        indent() << " ::apache::thrift::TProcessorContextFreer freer(" <<
           "this->eventHandler_.get(), ctx, \"" << service_func_name << "\");" <<
           endl << endl;
 
@@ -3547,10 +4184,10 @@ void t_cpp_generator::generate_process_function(t_service* tservice,
           service_func_name << "\");" << endl <<
         indent() << "}" << endl <<
         endl <<
-        indent() << "apache::thrift::TApplicationException x(e.what());" <<
+        indent() << " ::apache::thrift::TApplicationException x(e.what());" <<
           endl <<
         indent() << "oprot->writeMessageBegin(\"" << tfunction->get_name() <<
-          "\", apache::thrift::protocol::T_EXCEPTION, seqid);" << endl <<
+          "\", ::apache::thrift::protocol::T_EXCEPTION, seqid);" << endl <<
         indent() << "x.write(oprot);" << endl <<
         indent() << "oprot->writeMessageEnd();" << endl <<
         indent() << "oprot->getTransport()->writeEnd();" << endl <<
@@ -3568,7 +4205,7 @@ void t_cpp_generator::generate_process_function(t_service* tservice,
           service_func_name << "\");" << endl <<
         indent() << "}" << endl << endl <<
         indent() << "oprot->writeMessageBegin(\"" << tfunction->get_name() <<
-          "\", apache::thrift::protocol::T_REPLY, seqid);" << endl <<
+          "\", ::apache::thrift::protocol::T_REPLY, seqid);" << endl <<
         indent() << "result.write(oprot);" << endl <<
         indent() << "oprot->writeMessageEnd();" << endl <<
         indent() << "uint32_t bytes = oprot->getTransport()->writeEnd();" <<
@@ -3586,6 +4223,129 @@ void t_cpp_generator::generate_process_function(t_service* tservice,
 }
 
 /**
+ * Generates async process function definitions.
+ *
+ * @param tfunction The function to write a dispatcher for
+ */
+void t_cpp_generator::generate_async_process_function(t_service* tservice,
+																												 t_function* tfunction) {
+  // Open function
+  f_service_ <<
+    "void " << tservice->get_name() << "AsyncProcessor::" <<
+    "process_" << tfunction->get_name() <<
+    "(int32_t seqid, boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot)" << endl;
+  scope_up(f_service_);
+
+  string argsname = tservice->get_name() + "_" + tfunction->get_name() + "_args";
+  string resultname = tservice->get_name() + "_" + tfunction->get_name() + "_result";
+  string sharedfuturename = tservice->get_name() + "AsyncIf::" + tfunction->get_name() + "_shared_future_t";
+
+  f_service_ <<
+    indent() << argsname << " args;" << endl <<
+    indent() << "args.read(piprot.get());" << endl <<
+    indent() << "piprot->readMessageEnd();" << endl <<
+    indent() << "piprot->getTransport()->readEnd();" << endl <<
+    endl;
+
+  //t_struct* xs = tfunction->get_xceptions();
+  //const std::vector<t_field*>& xceptions = xs->get_members();
+  //vector<t_field*>::const_iterator x_iter;
+
+  // Generate the function call
+  t_struct* arg_struct = tfunction->get_arglist();
+  const std::vector<t_field*>& fields = arg_struct->get_members();
+  vector<t_field*>::const_iterator f_iter;
+
+  if (!tfunction->is_oneway()) {
+    f_service_ << indent() << sharedfuturename << " future = ";
+  } else {
+    f_service_ << indent();
+  }
+
+  bool first = true;
+  f_service_ <<
+    "iface_->" << tfunction->get_name() << "(";
+
+  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
+    if (first) {
+      first = false;
+    } else {
+      f_service_ << ", ";
+    }
+    f_service_ << "args." << (*f_iter)->get_name();
+  }
+  f_service_ << ");" << endl;
+
+  // Callbacks
+  if (!tfunction->is_oneway()) {
+    if (!tfunction->get_returntype()->is_void()) {
+      f_service_ <<
+	indent() << "future.setCallback(boost::bind(&" << tservice->get_name() << "AsyncProcessor::success_" << tfunction->get_name() << ", this, seqid, poprot, _1));" << endl;
+    }
+    else {
+      f_service_ <<
+	indent() << "future.setCallback(boost::bind(&" << tservice->get_name() << "AsyncProcessor::success_" << tfunction->get_name() << ", this, seqid, poprot));" << endl;
+    }
+    f_service_ <<
+      indent() << "future.setErrback(boost::bind(&" << tservice->get_name() << "AsyncProcessor::reply_" << tfunction->get_name() << ", this, seqid, poprot, _1));" << endl;
+  }
+
+	scope_down(f_service_);
+	f_service_ << endl;
+
+  if (!tfunction->is_oneway()) {
+		// Success implementation
+		if (!tfunction->get_returntype()->is_void()) {
+			indent(f_service_) <<
+				"void " << tservice->get_name() << "AsyncProcessor::success_" << tfunction->get_name() << "(int32_t seqid, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, " << type_name(tfunction->get_returntype()) << " value)" << endl;
+		}
+		else {
+			indent(f_service_) <<
+				"void " << tservice->get_name() << "AsyncProcessor::success_" << tfunction->get_name() << "(int32_t seqid, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot)" << endl;
+		}
+		scope_up(f_service_);
+		indent(f_service_) << resultname << " result;" << endl;
+		// Set isset on success field
+		if (!tfunction->get_returntype()->is_void()) {
+			indent(f_service_) << "result.success = value;" << endl;
+			indent(f_service_) << "result.__isset.success = true;" << endl;
+		}
+		indent(f_service_) << "reply_" << tfunction->get_name() << "(seqid, poprot, result);" << endl;
+		scope_down(f_service_);
+		f_service_ << endl;
+
+		// Reply implementation
+		indent(f_service_) <<
+      "void " << tservice->get_name() << "AsyncProcessor::reply_" << tfunction->get_name() << "(int32_t seqid, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, " << resultname << " result)" << endl;
+		scope_up(f_service_);
+
+		// Send failure tapplication exception
+    f_service_ <<
+      indent() << "if (result.__isset.failure) {" << endl <<
+      indent() << "  poprot->writeMessageBegin(\"" << tfunction->get_name() << "\", apache::thrift::protocol::T_EXCEPTION, seqid);" << endl <<
+      indent() << "  result.failure.write(poprot.get());" << endl <<
+      indent() << "  poprot->writeMessageEnd();" << endl <<
+      indent() << "  poprot->getTransport()->flush();" << endl <<
+      indent() << "  poprot->getTransport()->writeEnd();" << endl <<
+      indent() << "  return;" << endl <<
+			indent() << "}" << endl;
+
+		// Serialize the result into a struct
+		f_service_ <<
+			endl <<
+			indent() << "poprot->writeMessageBegin(\"" << tfunction->get_name() << "\", apache::thrift::protocol::T_REPLY, seqid);" << endl <<
+			indent() << "result.write(poprot.get());" << endl <<
+			indent() << "poprot->writeMessageEnd();" << endl <<
+			indent() << "poprot->getTransport()->flush();" << endl <<
+			indent() << "poprot->getTransport()->writeEnd();" << endl;
+
+		// Close function
+		scope_down(f_service_);
+		f_service_ << endl;
+	}
+}
+
+/**
  * Generates a skeleton file of a server
  *
  * @param tservice The service to generate a server for.
@@ -4358,6 +5118,39 @@ string t_cpp_generator::function_signature(t_function* tfunction,
 }
 
 /**
+ * Renders a function signature of the form 'type name(args, callback)'
+ *
+ * @param tfunction Function definition
+ * @return String of rendered function definition
+ */
+string t_cpp_generator::async_function_signature(t_service* tservice,
+						 t_function* tfunction,
+						 string method_prefix,
+						 string return_prefix,
+						 bool name_params) {
+  t_struct* arglist = tfunction->get_arglist();
+
+  return
+    // Return type
+    (tfunction->is_oneway() ? "void " :
+     return_prefix + tfunction->get_name() + "_shared_future_t ") +
+    // Function name
+    method_prefix + tfunction->get_name() +
+    // Args
+    "(" + argument_list(arglist, name_params) + ")";
+}
+
+string t_cpp_generator::async_recv_signature(t_service* tservice,
+					     t_function* tfunction,
+					     string prefix,
+					     bool name_params) {
+  //  t_type* ttype = tfunction->get_returntype();
+
+  return "void " + prefix + "recv_" + tfunction->get_name() + "(boost::shared_ptr<apache::thrift::protocol::TProtocol> iprot, std::string fname, apache::thrift::protocol::TMessageType mtype, " + tfunction->get_name() + "_shared_promise_t promise)";
+}
+
+
+/**
  * Renders a field list
  *
  * @param tstruct The struct definition
@@ -4495,5 +5288,6 @@ THRIFT_REGISTER_GENERATOR(cpp, "C++",
 "    pure_enums:      Generate pure enums instead of wrapper classes.\n"
 "    dense:           Generate type specifications for the dense protocol.\n"
 "    include_prefix:  Use full include paths in generated files.\n"
+"    async:           Generate code for asynchronous callbacks.\n"
 )
 
diff --git a/third_party/thrift-0.8.0/configure.ac b/third_party/thrift-0.8.0/configure.ac
index 37b24ac..a1681ff 100644
--- a/third_party/thrift-0.8.0/configure.ac
+++ b/third_party/thrift-0.8.0/configure.ac
@@ -120,6 +120,7 @@ if test "$with_cpp" = "yes";  then
   have_zlib=$success
 fi
 AM_CONDITIONAL([WITH_CPP], [test "$have_cpp" = "yes"])
+AM_CONDITIONAL([AMX_HAVE_BOOST], [test "$have_cpp" = "yes"])
 AM_CONDITIONAL([AMX_HAVE_LIBEVENT], [test "$have_libevent" = "yes"])
 AM_CONDITIONAL([AMX_HAVE_ZLIB], [test "$have_zlib" = "yes"])
 
@@ -462,6 +463,7 @@ AC_CONFIG_FILES([
   lib/cpp/thrift-nb.pc
   lib/cpp/thrift-z.pc
   lib/cpp/thrift.pc
+  lib/cpp/thrift-asio.pc
   lib/c_glib/Makefile
   lib/c_glib/thrift_c_glib.pc
   lib/c_glib/test/Makefile
diff --git a/third_party/thrift-0.8.0/lib/cpp/Makefile.am b/third_party/thrift-0.8.0/lib/cpp/Makefile.am
index f526479..33bc838 100644
--- a/third_party/thrift-0.8.0/lib/cpp/Makefile.am
+++ b/third_party/thrift-0.8.0/lib/cpp/Makefile.am
@@ -31,6 +31,10 @@ libthrift_la_LDFLAGS = -release $(VERSION) $(BOOST_LDFLAGS)
 
 ## We only build the extra libraries if we have the dependencies,
 ## but we install all of the headers unconditionally.
+if AMX_HAVE_BOOST
+lib_LTLIBRARIES += libthriftasio.la
+pkgconfig_DATA += thrift-asio.pc
+endif
 if AMX_HAVE_LIBEVENT
 lib_LTLIBRARIES += libthriftnb.la
 pkgconfig_DATA += thrift-nb.pc
@@ -87,6 +91,8 @@ libthrift_la_SOURCES += src/concurrency/Mutex.cpp \
                         src/concurrency/PosixThreadFactory.cpp
 endif
 
+libthriftasio_la_SOURCES = src/async/TAsioAsync.cpp
+
 libthriftnb_la_SOURCES = src/server/TNonblockingServer.cpp \
                          src/async/TAsyncProtocolProcessor.cpp \
                          src/async/TEvhttpServer.cpp \
@@ -95,6 +101,7 @@ libthriftnb_la_SOURCES = src/server/TNonblockingServer.cpp \
 libthriftz_la_SOURCES = src/transport/TZlibTransport.cpp
 
 # Flags for the various libraries
+libthriftasio_la_CPPFLAGS = $(AM_CPPFLAGS) $(BOOST_CPPFLAGS)
 libthriftnb_la_CPPFLAGS = $(AM_CPPFLAGS) $(LIBEVENT_CPPFLAGS)
 libthriftz_la_CPPFLAGS  = $(AM_CPPFLAGS) $(ZLIB_CPPFLAGS)
 libthriftnb_la_CXXFLAGS = $(AM_CXXFLAGS)
@@ -207,6 +214,7 @@ WINDOWS_DIST = \
 EXTRA_DIST = \
              README \
              README.SSL \
+             thrift-asio.pc.in \
              thrift-nb.pc.in \
              thrift.pc.in \
              thrift-z.pc.in \
diff --git a/third_party/thrift-0.8.0/lib/cpp/src/Thrift.h b/third_party/thrift-0.8.0/lib/cpp/src/Thrift.h
index 60a66f4..7e4b7b1 100644
--- a/third_party/thrift-0.8.0/lib/cpp/src/Thrift.h
+++ b/third_party/thrift-0.8.0/lib/cpp/src/Thrift.h
@@ -37,6 +37,13 @@
 #ifdef HAVE_INTTYPES_H
 #include <inttypes.h>
 #endif
+
+/**
+ * CONTRAIL-CUSTOM
+ */
+#include <netinet/in.h>
+#include <sys/socket.h>
+
 #include <string>
 #include <map>
 #include <list>
diff --git a/third_party/thrift-0.8.0/lib/cpp/src/async/TAsioAsync.cpp b/third_party/thrift-0.8.0/lib/cpp/src/async/TAsioAsync.cpp
new file mode 100644
index 0000000..e2c1832
--- /dev/null
+++ b/third_party/thrift-0.8.0/lib/cpp/src/async/TAsioAsync.cpp
@@ -0,0 +1,308 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#include "TAsioAsync.h"
+#include <iostream>
+
+using std::cout;
+using std::endl;
+
+// #define DEBUG_PRINT_PACKETS
+
+namespace apache { namespace thrift { namespace async {
+
+  // namespace { // begin anonymous namespace
+
+struct message {
+  int len;
+  boost::shared_array<uint8_t> buf;
+};
+
+class TAsioOutputTransport : public TAsyncOutputTransport {
+  // This class should not be used outside TAsioAsync.cpp, consider moving it there.
+ public:
+  TAsioOutputTransport(boost::shared_ptr<boost::asio::ip::tcp::socket> socket) :
+    socket_(socket),
+    isCurrentlyWriting_(false)
+    {}
+
+  void write_virt(const uint8_t* buf, uint32_t len) {  // from transport::TTransport
+    outData_.insert(outData_.end(), &buf[0], &buf[len]);
+  }
+  
+  void flush() {  // from transport::TTransport
+    uint32_t outDataSize = outData_.size();
+    message m;
+    m.len = outDataSize + 4;
+    m.buf = boost::shared_array<uint8_t>(new uint8_t[outDataSize + 4]);
+    
+    // Put data in the outbuffer
+    m.buf[0] = (outDataSize >> 24) & 0xff;
+    m.buf[1] = (outDataSize >> 16) & 0xff;
+    m.buf[2] = (outDataSize >>  8) & 0xff;
+    m.buf[3] = (outDataSize >>  0) & 0xff;
+    std::copy(outData_.begin(), outData_.end(), &m.buf[4]);
+    
+#ifdef DEBUG_PRINT_PACKETS
+    printf("output: ");
+    for (int i = 0; i < outDataSize; i++)
+      printf("%02x ", outData_[i]);
+    printf("\n");
+#endif
+
+    // Delete internal buffer
+    outData_.clear();
+    
+    // Queue into buffer
+    outQueue_.push_back(m);  
+  
+    // If not currently writing, start
+    if (!isCurrentlyWriting_) {
+      isCurrentlyWriting_ = true;
+      writeNext();
+    }
+  }
+  
+  void writeNext() {
+    if (!outQueue_.size()) {
+      isCurrentlyWriting_ = false;
+      return;
+    }
+
+    // By passing m.buf as an argument, we are guaranteed that it will remain in memory
+    message m = outQueue_.front();
+    outQueue_.pop_front();
+    boost::asio::async_write(*socket_, boost::asio::buffer(m.buf.get(), m.len), boost::bind(&TAsioOutputTransport::handleWriteFinished, this, boost::asio::placeholders::error, m));
+  }
+  
+  void handleWriteFinished(const boost::system::error_code& error, const message& m) {
+    // Temporary memory buffer will be deleted when this scope closes
+    
+    if (error) {
+      GlobalOutput("An error occurred when writing message");
+      return;
+    }
+
+    writeNext();
+  }
+
+ private:
+  boost::shared_ptr<boost::asio::ip::tcp::socket> socket_;
+  std::vector<uint8_t> outData_;
+  bool isCurrentlyWriting_;
+  std::deque<message> outQueue_;
+};
+
+class TAsioInputTransport {
+ public:
+  TAsioInputTransport(boost::shared_ptr<boost::asio::ip::tcp::socket> socket) : 
+    socket_(socket)
+    {}
+
+  void read(boost::function<void (const uint8_t* buf, uint32_t len)> callback) {
+    boost::asio::async_read(*socket_, boost::asio::buffer(length_, 4), boost::bind(&TAsioInputTransport::handleReadLength, this/*shared_from_this()*/, _1, callback));
+  }
+
+ private:
+  void handleReadLength(const boost::system::error_code& error, boost::function<void (const uint8_t* buf, uint32_t len)> callback) {
+    if (error) {
+      GlobalOutput("An error occurred when reading length header");
+      return;
+      
+      // Note on memory: TAsioServerClient is actually owned by a shared_ptr from the callback, so it will be automatically destructed
+    }
+    uint32_t bufLen =
+      ((length_[0] & 0xff) << 24) |
+      ((length_[1] & 0xff) << 16) |
+      ((length_[2] & 0xff) <<  8) |
+      ((length_[3] & 0xff) <<  0);
+    
+    inData_.resize(bufLen);
+    boost::asio::async_read(*socket_, boost::asio::buffer(inData_, bufLen), boost::bind(&TAsioInputTransport::handleReadMessage, this/*shared_from_this()*/, _1, callback));
+  }
+
+  void handleReadMessage(const boost::system::error_code& error, boost::function<void (const uint8_t* buf, uint32_t len)> callback) {
+    if (error) {
+      GlobalOutput("An error occurred when reading frame");
+      return;
+      
+      // See comment about memory in handleReadLength
+    }
+
+    callback(&inData_[0], inData_.size());
+    inData_.clear();
+  }
+
+  uint8_t length_[4];
+  std::vector<uint8_t> inData_;
+  boost::shared_ptr<boost::asio::ip::tcp::socket> socket_;
+};
+
+
+class TAsioServerClient : public boost::enable_shared_from_this<TAsioServerClient> {
+  // This class should not be used outside TAsioAsync.cpp, consider moving it there.
+ public:
+  TAsioServerClient(boost::shared_ptr<boost::asio::ip::tcp::socket> socket,
+		    boost::shared_ptr<protocol::TProtocolFactory> iProtocolFactory,
+		    boost::shared_ptr<protocol::TProtocolFactory> oProtocolFactory,
+		    boost::shared_ptr<TProcessor> processor) :
+    iProtocolFactory_(iProtocolFactory),
+    oProtocolFactory_(oProtocolFactory),
+    processor_(processor),
+    iTransport_(socket),
+    oTransport_(new TAsioOutputTransport(socket))
+    { cout << "in TAsioServerClient constructor" << endl; }
+
+  void start() { cout << "in start " << endl; read(); }
+  
+  ~TAsioServerClient() {
+   GlobalOutput("Disconnecting client");
+  }
+
+ private:  
+  void read() {
+    iTransport_.read(boost::bind(&TAsioServerClient::handleMessage, /* this */shared_from_this(), _1, _2)); // todo: errback
+  }
+  
+  void handleMessage(const uint8_t* buf, uint32_t len) {
+    // todo: add error handling
+    
+    boost::shared_ptr<transport::TTransport> iTransport(new transport::TMemoryBuffer(const_cast<uint8_t*>(buf), len));  // TMemoryBuffer guarantees it will not touch
+    boost::shared_ptr<protocol::TProtocol> iProtocol(iProtocolFactory_->getProtocol(iTransport));
+    boost::shared_ptr<protocol::TProtocol> oProtocol(oProtocolFactory_->getProtocol(oTransport_));
+    
+    #ifdef DEBUG_PRINT_PACKETS
+    printf("input: ");
+    int i;
+    for (i = 0; i < len; i++)
+      printf("%02x ", buf[i]);
+    printf("i = %02x \n", i);
+    #endif
+    
+    processor_->process(iProtocol, oProtocol, NULL); //TODO: what context should be used here?
+    read();
+  }
+
+  boost::shared_ptr<boost::asio::ip::tcp::socket> socket_;
+  boost::shared_ptr<protocol::TProtocolFactory> iProtocolFactory_;
+  boost::shared_ptr<protocol::TProtocolFactory> oProtocolFactory_;
+  boost::shared_ptr<TProcessor> processor_;
+  TAsioInputTransport iTransport_;
+  boost::shared_ptr<TAsioOutputTransport> oTransport_;
+};
+
+  // } // end anonymous namespace
+
+void TAsioServer::serve() {
+  socket_.reset(new boost::asio::ip::tcp::socket(io_service_)); // socket of the next client
+  acceptor_.async_accept(*socket_, boost::bind(&TAsioServer::handleAccept, shared_from_this(), boost::asio::placeholders::error));
+}
+
+void TAsioServer::handleAccept(const boost::system::error_code& error) {
+  if (error) {
+    GlobalOutput("An error occurred while accepting");
+    return;
+    // We will stop accepting at this point
+    // Call errback?
+  }
+  
+  boost::shared_ptr<TAsioServerClient> client(new TAsioServerClient(socket_, iProtocolFactory_, oProtocolFactory_, processor_));
+  client->start();
+  
+  serve(); // next client plz
+}
+
+boost::shared_ptr<TAsyncOutputTransport> TAsioClient::getOutputTransport() {
+  return boost::shared_ptr<TAsyncOutputTransport>(new TAsioOutputTransport(socket_));
+}
+
+void TAsioClient::startReadingInput(boost::shared_ptr<TProcessor> processor) {
+  boost::shared_ptr<TAsioInputTransport> iTransport(new TAsioInputTransport(socket_));
+    
+  // Start read loop. iTransport will stay in memory as long as the loop is still running, since it is being referred
+  // to from the shared_ptr in the callback.
+  iTransport->read(boost::bind(&TAsioClient::handleMessage, shared_from_this(), _1, _2, iTransport, processor)); // todo: errback
+}
+
+void TAsioClient::handleMessage(const uint8_t* buf, uint32_t len, boost::shared_ptr<TAsioInputTransport> iTransport, boost::shared_ptr<TProcessor> processor) {
+  // I'm binding iTransport and processor so that these will stay in scope as long as data is read. Not too happy about
+  // this, but is there a better way of doing it?
+
+  boost::shared_ptr<transport::TTransport> iTransport2(new transport::TMemoryBuffer(const_cast<uint8_t*>(buf), len));
+  boost::shared_ptr<protocol::TProtocol> iProtocol(iProtocolFactory_->getProtocol(iTransport2));
+  
+  processor->process(iProtocol, NULL); //TODO: what context should be used here?
+
+  // Read next message
+  iTransport->read(boost::bind(&TAsioClient::handleMessage, shared_from_this(), _1, _2, iTransport, processor)); // todo: errback
+}
+
+void TAsioClient::connectSimple(const std::string& host, short port, boost::function<void (void)> callback) {
+  // Start an asynchronous resolve to translate the server and service names
+  // into a list of endpoints.
+  std::stringstream ss;
+  ss << port;
+  boost::asio::ip::tcp::resolver::query query(host, ss.str());
+  resolver_.async_resolve(query,
+			  boost::bind(&TAsioClient::handleResolve, this,
+				      boost::asio::placeholders::error,
+				      boost::asio::placeholders::iterator,
+				      callback));
+}
+
+void TAsioClient::handleResolve(const boost::system::error_code& err,
+			    boost::asio::ip::tcp::resolver::iterator endpoint_iterator,
+			    boost::function<void (void)> callback) {
+  if (!err) {
+    // Attempt a connection to the first endpoint in the list. Each endpoint
+    // will be tried until we successfully establish a connection.
+    boost::asio::ip::tcp::endpoint endpoint = *endpoint_iterator;
+    socket_->async_connect(endpoint,
+			   boost::bind(&TAsioClient::handleConnect, this,
+				       boost::asio::placeholders::error,
+				       ++endpoint_iterator,
+				       callback));
+  } else {
+    GlobalOutput.printf("Error: %s", err.message().c_str());
+  }
+}
+
+void TAsioClient::handleConnect(const boost::system::error_code& err,
+			    boost::asio::ip::tcp::resolver::iterator endpoint_iterator,
+			    boost::function<void (void)> callback) {
+  if (!err) {
+    // Everything is connected, now let's build the client and etc...
+    callback();
+    
+  } else if (endpoint_iterator != boost::asio::ip::tcp::resolver::iterator()) {
+    // The connection failed. Try the next endpoint in the list.
+    socket_->close();
+    boost::asio::ip::tcp::endpoint endpoint = *endpoint_iterator;
+    socket_->async_connect(endpoint,
+			   boost::bind(&TAsioClient::handleConnect, this,
+				       boost::asio::placeholders::error,
+				       ++endpoint_iterator,
+				       callback));
+  } else {
+    GlobalOutput.printf("Error: %s", err.message().c_str());
+    // Todo: call user-provided errback
+  }
+}
+
+} } }
diff --git a/third_party/thrift-0.8.0/lib/cpp/src/async/TAsioAsync.h b/third_party/thrift-0.8.0/lib/cpp/src/async/TAsioAsync.h
new file mode 100644
index 0000000..064b7bb
--- /dev/null
+++ b/third_party/thrift-0.8.0/lib/cpp/src/async/TAsioAsync.h
@@ -0,0 +1,142 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifndef _TASIOASYNC_H_
+#define _TASIOASYNC_H_
+
+#include <async/TAsync.h>
+#include <transport/TBufferTransports.h>
+#include <boost/enable_shared_from_this.hpp>
+#include <boost/asio.hpp>
+#include <boost/bind.hpp>
+#include <boost/function.hpp>
+#include <boost/shared_array.hpp>
+#include <vector>
+#include <deque>
+#include <protocol/TProtocol.h>
+#include <TProcessor.h>
+
+namespace apache { namespace thrift { namespace async {
+
+class TAsioInputTransport; // fwd declaration
+
+class TAsioServer : public boost::enable_shared_from_this<TAsioServer> {
+  // Class for a Thrift server.
+  // The server must be instantiated within a shared_ptr or else it will throw tr1::weak_ptr
+ public:
+  TAsioServer(boost::asio::io_service& io_service,
+	      short port,
+	      boost::shared_ptr<protocol::TProtocolFactory> iProtocolFactory,
+	      boost::shared_ptr<protocol::TProtocolFactory> oProtocolFactory,
+	      boost::shared_ptr<TProcessor> processor) :
+    io_service_(io_service),
+    acceptor_(io_service, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port)),
+    iProtocolFactory_(iProtocolFactory),
+    oProtocolFactory_(oProtocolFactory),
+    processor_(processor)
+    {}
+
+  void start() { serve(); }
+
+ private:
+  void serve();
+  void handleAccept(const boost::system::error_code& error);
+
+  boost::asio::io_service& io_service_;
+  boost::asio::ip::tcp::acceptor acceptor_;
+  boost::shared_ptr<protocol::TProtocolFactory> iProtocolFactory_;
+  boost::shared_ptr<protocol::TProtocolFactory> oProtocolFactory_;
+  boost::shared_ptr<TProcessor> processor_;
+  boost::shared_ptr<boost::asio::ip::tcp::socket> socket_;
+};
+
+class TAsioClient : public boost::enable_shared_from_this<TAsioClient> {
+  // Class for client connections
+
+  // This class must be instantiated within a boost::shared_ptr or else it will throw a
+  // tr1::weak_ptr upon connect. 
+  // Bad:  TAsioClient t(...)
+  // Good: boost::shared_ptr<TAsioClient> t(...)
+
+ public:
+  TAsioClient(boost::asio::io_service& io_service,
+	      boost::shared_ptr<protocol::TProtocolFactory> iProtocolFactory,
+	      boost::shared_ptr<protocol::TProtocolFactory> oProtocolFactory
+	      ) :
+    resolver_(io_service),
+    socket_(new boost::asio::ip::tcp::socket(io_service)),
+    iProtocolFactory_(iProtocolFactory),
+    oProtocolFactory_(oProtocolFactory)
+    {}
+
+  template<typename T>
+    void connect(const std::string& host, short port, void (&callback)(boost::shared_ptr<T> client)) {
+      // Constructor of boost::function seems to be unable to do an automatic cast of raw function pointers, so we provide
+      // this convenience method wrapping connect(...).
+      boost::function<void (boost::shared_ptr<T> client)> callback2(callback);
+      connect(host, port, callback2);
+    }
+
+  template<typename T>
+    void connect(const std::string& host, short port, boost::function<void (boost::shared_ptr<T> client)> callback) {
+    // T is inferred from the type of the callback. I'm not too sure if this is apparent.
+    // This function untemplatizes by binding a new callback to build<T> and passing it on to the internal connect code.
+    // The reason we need to use templates at all is that we have to construct arbitrary processor objects within the
+    // scope of TAsioClient. We couldn't let the user provide us with an processor object since the processor is
+    // dependent on internals of TAsioClient (the output transport), and internals of TAsioClient (the input transport)
+    // is dependent on the processor. See how build(...) works.
+    boost::function<void (void)> finalCallback = boost::bind(&TAsioClient::build<T>, this, callback);
+    connectSimple(host, port, finalCallback);
+  }
+
+ private:
+  template<typename T>
+    void build(boost::function<void (boost::shared_ptr<T> client)> callback) {
+    // We are connected, let's build the client.
+    boost::shared_ptr<T> client(new T(getOutputTransport(), oProtocolFactory_));
+    boost::shared_ptr<TProcessor> processor(client); // Simply reinterpreted as a base class (T is derived from TProcessor)
+
+    startReadingInput(processor);
+
+    // Call user-provided callback to signal success.
+    callback(client);
+  }
+
+  boost::shared_ptr<TAsyncOutputTransport> getOutputTransport();
+  void startReadingInput(boost::shared_ptr<TProcessor> processor);
+
+  void handleMessage(const uint8_t* buf, uint32_t len, boost::shared_ptr<TAsioInputTransport> iTransport, boost::shared_ptr<TProcessor> processor);
+  void connectSimple(const std::string& host, short port, boost::function<void (void)> callback);
+  void handleResolve(const boost::system::error_code& err,
+		     boost::asio::ip::tcp::resolver::iterator endpoint_iterator,
+		     boost::function<void (void)> callback);
+  void handleConnect(const boost::system::error_code& err,
+		     boost::asio::ip::tcp::resolver::iterator endpoint_iterator,
+		     boost::function<void (void)> callback);
+
+
+  boost::asio::ip::tcp::resolver resolver_;
+  boost::shared_ptr<boost::asio::ip::tcp::socket> socket_;
+  boost::shared_ptr<protocol::TProtocolFactory> iProtocolFactory_;
+  boost::shared_ptr<protocol::TProtocolFactory> oProtocolFactory_;
+};
+
+} } }
+
+#endif
diff --git a/third_party/thrift-0.8.0/lib/cpp/src/async/TAsync.h b/third_party/thrift-0.8.0/lib/cpp/src/async/TAsync.h
new file mode 100644
index 0000000..1101dd9
--- /dev/null
+++ b/third_party/thrift-0.8.0/lib/cpp/src/async/TAsync.h
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifndef _TASYNC_H_
+#define _TASYNC_H_ 1
+
+#include <boost/function.hpp>
+#include <transport/TTransport.h>
+#include <boost/shared_ptr.hpp>
+
+namespace apache { namespace thrift { namespace async {
+
+class TAsyncOutputTransport : public transport::TTransport {
+  // Asynchronous transport.
+  //
+  // The asynchronousity gives us an interesting asymmetry. We are
+  // free to write to an underlying socket at any time, but cannot
+  // read from it in any way. This class is simply meant to be a
+  // superclass of unidirectional nonblocking out transports,
+  // disallowing the read method.
+
+ public:
+  virtual void write_virt(const uint8_t* /* buf */, uint32_t /* len */) = 0;
+  virtual void flush() = 0;
+
+  virtual uint32_t read_virt(uint8_t* /* buf */, uint32_t /* len */) {
+    // This method should not be overridden!!
+    throw transport::TTransportException(transport::TTransportException::NOT_OPEN, "Asynchronous transports cannot read.");
+  }
+
+  virtual ~TAsyncOutputTransport() {}
+};
+
+// More stuff should go here, so far not enough generalization has been done
+
+} } }
+
+#endif
diff --git a/third_party/thrift-0.8.0/lib/cpp/src/async/TFuture.h b/third_party/thrift-0.8.0/lib/cpp/src/async/TFuture.h
new file mode 100644
index 0000000..bfdef85
--- /dev/null
+++ b/third_party/thrift-0.8.0/lib/cpp/src/async/TFuture.h
@@ -0,0 +1,282 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifndef _THRIFT_TCONTROLLER_H_
+#define _THRIFT_TCONTROLLER_H_ 1
+
+#include <boost/function.hpp>
+#include <concurrency/Mutex.h>
+#include <boost/shared_ptr.hpp>
+#include <iostream>
+
+namespace {
+void warn(const char s[]) {
+  std::cerr << "Warning: " << s << std::endl;
+}
+}
+
+namespace apache { namespace thrift { namespace async {
+
+/*********************** TController *****************/
+
+template <typename result_t, typename success_t, typename success_constref_t>
+class TBaseController {
+ public:
+  TBaseController() : executed_(false), has_success_(false), has_error_(false) { }
+  TBaseController(success_constref_t success) : executed_(false), has_success_(true), has_error_(false) { result_.success = success; }
+  TBaseController(const result_t& result) : executed_(false), has_success_(false), has_error_(true), result_(result) { }
+  ~TBaseController() {
+  }
+  result_t &result() { return result_; }
+  success_t &success() { return result_.success; }
+
+  void callback() {
+    concurrency::Guard g(mutex_);
+    if (has_success_) warn("TController already has success");
+    has_success_ = true;
+    if (callback_) runCallback();
+  }
+  void errback() {
+    concurrency::Guard g(mutex_);
+    if (has_error_) warn("TController already has error");
+    has_error_ = true;
+    if (errback_) runErrback();
+  }
+  void callback(success_constref_t success) {  // shorthand for callback()
+    concurrency::Guard g(mutex_);
+    if (has_success_) warn("TController already has success");
+    has_success_ = true;
+    result_.success = success;
+    if (callback_) runCallback();
+  }
+  void errback(const result_t &result) {  // shorthand for errback()
+    concurrency::Guard g(mutex_);
+    if (has_error_) warn("TController already has error");
+    has_error_ = true;
+    result_ = result;
+    if (errback_) runErrback();
+  }
+  TBaseController<result_t, success_t, success_constref_t>& setCallback(boost::function<void (success_constref_t)> callback) {
+    concurrency::Guard g(mutex_);
+    if (callback_) warn("TController already has callback");
+    callback_ = callback;
+    if (has_success_) runCallback();
+    return *this;
+  }
+  TBaseController<result_t, success_t, success_constref_t>& setErrback(boost::function<void (const result_t &)> errback) {
+    concurrency::Guard g(mutex_);
+    if (errback_) warn("TController already has errback");
+    errback_ = errback;
+    if (has_error_) runErrback();
+    return *this;
+  }
+ private:
+  void runCallback() { // Invoked as soon as there is both a success and a callback set
+    if (executed_) warn("TController has already been executed");
+    executed_ = true;
+    callback_(result_.success);
+  }
+  void runErrback() { // Invoked as soon as there is both a success and a callback set
+    if (executed_) warn("TController has already been executed");
+    executed_ = true;
+    errback_(result_);
+  }
+  bool has_success_, has_error_, executed_;
+  result_t result_;
+  boost::function<void (success_constref_t)> callback_;
+  boost::function<void (const result_t&)> errback_;
+  concurrency::Mutex mutex_;
+};
+
+template <typename result_t>
+class TBaseController<result_t, void, void> {
+ public:
+  TBaseController() : executed_(false), has_success_(false), has_error_(false) { }
+  TBaseController(bool success) : executed_(false), has_success_(true), has_error_(false) { }
+  TBaseController(const result_t& result) : has_success_(false), has_error_(true), result_(result) {
+    has_error_ = true;
+  }
+  ~TBaseController() {
+    if (!executed_) warn("TController expired without being executed");
+  }
+  result_t &result() { return result_; }
+
+  void callback() {
+    concurrency::Guard g(mutex_);
+    if (has_success_) warn("TController already has success");
+    has_success_ = true;
+    if (callback_) runCallback();
+  }
+  void errback() {
+    concurrency::Guard g(mutex_);
+    if (has_error_) warn("TController already has error");
+    has_error_ = true;
+    if (errback_) runErrback();
+  }
+  void errback(const result_t &result) {  // shorthand for errback()
+    concurrency::Guard g(mutex_);
+    if (has_error_) warn("TController already has error");
+    has_error_ = true;
+    result_ = result;
+    if (errback_) runErrback();
+  }
+  TBaseController<result_t, void, void>& setCallback(boost::function<void (void)> callback) {
+    concurrency::Guard g(mutex_);
+    if (callback_) warn("TController already has callback");
+    callback_ = callback;
+    if (has_success_) runCallback();
+    return *this;
+  }
+  TBaseController<result_t, void, void>& setErrback(boost::function<void (const result_t &)> errback) {
+    concurrency::Guard g(mutex_);
+    if (errback_) warn("TController already has errback");
+    errback_ = errback;
+    if (has_error_) runErrback();
+    return *this;
+  }
+ private:
+  void runCallback() { // Invoked as soon as there is both a success and a callback set
+    if (executed_) warn("TController has already been executed");
+    executed_ = true;
+    callback_();
+  }
+  void runErrback() { // Invoked as soon as there is both a success and a callback set
+    if (executed_) warn("TController has already been executed");
+    executed_ = true;
+    errback_(result_);
+  }
+  bool has_success_, has_error_, executed_;
+  result_t result_;
+  boost::function<void (void)> callback_;
+  boost::function<void (result_t)> errback_;
+  concurrency::Mutex mutex_;
+};
+
+template <typename result_t>
+class TController : public TBaseController<result_t, typename result_t::success_t, typename result_t::success_constref_t> {
+  // success_constref_t is equal to:
+  // - success_t          when success_t is plain old data (such as int, bool etc.)
+  // - const success_t&   when success_t is a complex type (i.e. user-defined structs)
+  //
+  // success_nonvoid_t is equal to:
+  // - success_t          when success_t is not void
+  // - bool               when success_t is void
+  //
+  // success_constref_nonvoid_t is equal to:
+  // - success_constref_t when success_t is not void
+  // - bool               when success_t is void
+ public:
+  TController() : TBaseController<result_t, typename result_t::success_t, typename result_t::success_constref_t>() {}
+  TController(typename result_t::success_constref_nonvoid_t success) : TBaseController<result_t, typename result_t::success_t, typename result_t::success_constref_t>(success) {}
+  TController(const result_t& result) : TBaseController<result_t, typename result_t::success_t, typename result_t::success_constref_t>(result) {}
+};
+
+/*********************** TSharedPromise *****************/
+
+template<typename result_t, typename success_t, typename success_constref_t> class TBaseSharedFuture; // fwd declaration for friend class
+
+template <typename result_t, typename success_t, typename success_constref_t>
+class TBaseSharedPromise {
+  friend class TBaseSharedFuture<result_t, success_t, success_constref_t>; // needs to touch its p_
+ public:
+  TBaseSharedPromise() : p_(new TController<result_t>) {}
+  TBaseSharedPromise(const TBaseSharedPromise& rhs) : p_(rhs.p_) {}
+  TBaseSharedPromise(const result_t& result) : p_(new TController<result_t>(result)) {}
+  TBaseSharedPromise(success_constref_t success) : p_(new TController<result_t>(success)) {}
+
+  void callback() { p_->callback(); }
+  void errback() { p_->errback(); }
+  void callback(success_constref_t success) { p_->callback(success); }
+  void errback(const result_t& result) { p_->errback(result); }
+  result_t& result() { return p_->result(); }
+  success_t& success() { return p_->success(); }
+
+ private:
+  boost::shared_ptr<TController<result_t> > p_;
+};
+
+template <typename result_t>
+class TBaseSharedPromise<result_t, void, void> {
+  friend class TBaseSharedFuture<result_t, void, void>; // needs to touch its p_
+ public:
+  TBaseSharedPromise() : p_(new TController<result_t>) {}
+  TBaseSharedPromise(const TBaseSharedPromise& rhs) : p_(rhs.p_) {}
+  TBaseSharedPromise(const result_t& result) : p_(new TController<result_t>(result)) {}
+  TBaseSharedPromise(bool success) : p_(new TController<result_t>(success)) {}
+
+  void callback() { p_->callback(); }
+  void errback() { p_->errback(); }
+  void errback(const result_t& result) { p_->errback(result); }
+  result_t& result() { return p_->result(); }
+
+ private:
+  boost::shared_ptr<TController<result_t> > p_;
+};
+
+template <typename result_t>
+class TSharedPromise : public TBaseSharedPromise<result_t, typename result_t::success_t, typename result_t::success_constref_t> {
+ public:
+  TSharedPromise() : TBaseSharedPromise<result_t, typename result_t::success_t, typename result_t::success_constref_t>() {}
+  TSharedPromise(typename result_t::success_constref_nonvoid_t success) : TBaseSharedPromise<result_t, typename result_t::success_t, typename result_t::success_constref_t>(success) {}
+  TSharedPromise(const result_t& result) : TBaseSharedPromise<result_t, typename result_t::success_t, typename result_t::success_constref_t>(result) {}
+};
+
+/*********************** TSharedFuture *****************/
+
+template <typename result_t, typename success_t, typename success_constref_t>
+class TBaseSharedFuture {
+ public:
+  //  TBaseSharedFuture() : p_(new TController<result_t>) {}
+  TBaseSharedFuture(const TBaseSharedFuture& rhs) : p_(rhs.p_) {}
+  TBaseSharedFuture(const TSharedPromise<result_t>& rhs) : p_(rhs.p_) {}
+  TBaseSharedFuture(const result_t& result) : p_(new TController<result_t>(result)) {}
+  TBaseSharedFuture(success_constref_t success) : p_(new TController<result_t>(success)) {}
+
+  TBaseSharedFuture<result_t, success_t, success_constref_t>& setCallback(boost::function<void (success_constref_t)> callback) { p_->setCallback(callback); return *this; }
+  TBaseSharedFuture<result_t, success_t, success_constref_t>& setErrback(boost::function<void (const result_t &)> errback) { p_->setErrback(errback); return *this; }
+ private:
+  boost::shared_ptr<TController<result_t> > p_;
+};
+
+template <typename result_t>
+class TBaseSharedFuture<result_t, void, void> {
+ public:
+  //  TBaseSharedFuture() : p_(new TController<result_t>) {}
+  TBaseSharedFuture(const TBaseSharedFuture& rhs) : p_(rhs.p_) {}
+  TBaseSharedFuture(const TSharedPromise<result_t>& rhs) : p_(rhs.p_) {}
+  TBaseSharedFuture(const result_t& result) : p_(new TController<result_t>(result)) {}
+  TBaseSharedFuture(bool success) : p_(new TController<result_t>(success)) {}
+  TBaseSharedFuture<result_t, void, void>& setCallback(boost::function<void ()> callback) { p_->setCallback(callback); return *this; }
+  TBaseSharedFuture<result_t, void, void>& setErrback(boost::function<void (const result_t &)> errback) { p_->setErrback(errback); return *this; }
+ private:
+  boost::shared_ptr<TController<result_t> > p_;
+};
+
+template <typename result_t>
+class TSharedFuture : public TBaseSharedFuture<result_t, typename result_t::success_t, typename result_t::success_constref_t> {
+ public:
+  //  TSharedFuture() : TBaseSharedFuture<result_t, typename result_t::success_t, typename result_t::success_constref_t>() {}
+  TSharedFuture(const TSharedPromise<result_t>& rhs) : TBaseSharedFuture<result_t, typename result_t::success_t, typename result_t::success_constref_t>(rhs) {}
+  TSharedFuture(typename result_t::success_constref_nonvoid_t success) : TBaseSharedFuture<result_t, typename result_t::success_t, typename result_t::success_constref_t>(success) {}
+  TSharedFuture(const result_t& result) : TBaseSharedFuture<result_t, typename result_t::success_t, typename result_t::success_constref_t>(result) {}
+};
+
+} } }; // end namespaces
+
+#endif
diff --git a/third_party/thrift-0.8.0/lib/cpp/thrift-asio.pc.in b/third_party/thrift-0.8.0/lib/cpp/thrift-asio.pc.in
new file mode 100644
index 0000000..9046ae6
--- /dev/null
+++ b/third_party/thrift-0.8.0/lib/cpp/thrift-asio.pc.in
@@ -0,0 +1,30 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements. See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership. The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License. You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied. See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: Thrift
+Description: Thrift ASIO Asynchronous API
+Version: @VERSION@
+Requires: thrift = @VERSION@
+Libs: -L${libdir} -lthriftasio
+Cflags: -I${includedir}/thrift
diff --git a/third_party/thrift-0.8.0/tutorial/cpp-asio/CppClient.cpp b/third_party/thrift-0.8.0/tutorial/cpp-asio/CppClient.cpp
new file mode 100644
index 0000000..41f5f7e
--- /dev/null
+++ b/third_party/thrift-0.8.0/tutorial/cpp-asio/CppClient.cpp
@@ -0,0 +1,127 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#include <iostream>
+#include <istream>
+#include <ostream>
+#include <sstream>
+#include <string>
+#include <boost/asio.hpp>
+#include <boost/bind.hpp>
+
+#include <async/TAsioAsync.h>
+#include <protocol/TBinaryProtocol.h>
+
+#include "Calculator.h"
+
+using namespace apache::thrift;
+
+void pingCallback() {
+  printf("ping()\n");
+}
+
+void pingErrback(const tutorial::Calculator_ping_result& result) {
+  printf("Exception caught\n");
+}
+
+void addCallback(int32_t a, int32_t b, int32_t sum) {
+  printf("%d+%d=%d\n", a, b, sum);
+}
+
+void addErrback(const tutorial::Calculator_add_result& result) {
+  printf("Exception caught\n");
+}
+
+void calculateCallback(int32_t workID) {
+  printf("work id = %d\n", workID);
+}
+
+void calculateErrback(const tutorial::Calculator_calculate_result& result) {
+  printf("error: calculate: %s\n", result.ouch.why.c_str());
+}
+
+void getStructCallback(const shared::SharedStruct& result) {
+  printf("getStruct: %d: %s\n", result.key, result.value.c_str());
+}
+
+void getStructErrback(const shared::SharedService_getStruct_result& result) {
+  printf("getStruct error!\n");
+}
+
+void connected(boost::shared_ptr<tutorial::CalculatorAsyncClient> client) {
+  std::cout << "connected!!!" << std::endl;
+
+  // The server in async/CppServer.cpp has an add method which waits for a + b seconds before returning
+  client->add(2, 3).setCallback(boost::bind(&addCallback, 2, 3, _1)).setErrback(&addErrback);  // will return after 5s
+  client->add(1, 2).setCallback(boost::bind(&addCallback, 1, 2, _1)).setErrback(&addErrback);  // will return after 3s
+  client->add(1, 1).setCallback(boost::bind(&addCallback, 1, 1, _1)).setErrback(&addErrback);  // will return after 2s
+
+  // Will return immediately
+  client->ping().setCallback(pingCallback).setErrback(pingErrback);
+
+  tutorial::Work work;
+  work.op = tutorial::Operation::DIVIDE;
+  work.num1 = 42;
+  work.num2 = 0;
+
+  // Should throw a division by zero error exception
+  client->calculate(1, work).setCallback(calculateCallback).setErrback(calculateErrback);
+
+  // Create a normal request which should work fine
+  work.op = tutorial::Operation::ADD;
+  client->calculate(1, work).setCallback(calculateCallback).setErrback(calculateErrback);
+
+  // Should cause warnings from the TController when the result comes back but there is no handler ready
+  client->ping();
+
+  // calculate(...) writes to the log each time. We try to fetch the two first entries
+  client->getStruct(0).setCallback(getStructCallback).setErrback(getStructErrback);
+  client->getStruct(1).setCallback(getStructCallback).setErrback(getStructErrback);
+
+  // Oneway function returns void so we can't invoke setCallback/setErrback
+  client->zip();
+}
+
+int main(int argc, char* argv[])
+{
+  try
+  {
+    boost::asio::io_service io_service;
+
+    boost::shared_ptr<protocol::TProtocolFactory> protocolFactory(new protocol::TBinaryProtocolFactory());
+    
+    boost::shared_ptr<async::TAsioClient> client (
+						  new async::TAsioClient(
+									 io_service,
+									 protocolFactory,
+									 protocolFactory));
+
+    client->connect("localhost", 9090, connected);
+
+    io_service.run(); // Will block
+
+    printf("Done, returning\n");
+  }
+  catch (std::exception& e)
+  {
+    std::cout << "Exception: " << e.what() << "\n";
+  }
+
+  return 0;
+}
diff --git a/third_party/thrift-0.8.0/tutorial/cpp-asio/CppServer.cpp b/third_party/thrift-0.8.0/tutorial/cpp-asio/CppServer.cpp
new file mode 100644
index 0000000..5fc6983
--- /dev/null
+++ b/third_party/thrift-0.8.0/tutorial/cpp-asio/CppServer.cpp
@@ -0,0 +1,186 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#include <protocol/TBinaryProtocol.h>
+
+#include <iostream>
+#include <stdexcept>
+#include <sstream>
+
+#include <time.h>
+
+#include "../gen-cpp/Calculator.h"
+
+#include <async/TAsioAsync.h>
+#include <async/TFuture.h>
+
+using namespace apache::thrift;
+
+using namespace tutorial;
+using namespace shared;
+
+class CalculatorAsyncHandler : public CalculatorAsyncIf {
+ public:
+  CalculatorAsyncHandler(boost::asio::io_service& io_service) : io_service_(io_service) {}
+
+  virtual ping_shared_future_t ping() {
+    printf("ping()\n");
+    
+    // This method is declared as "void ping();", but we still want to notify the client
+    // that the method was invoked successfully.
+    // When we want to return immediately, there are convenience constructors to make this
+    // much less tedious. In this case, since void is not a legal type in C++, a dummy
+    // boolean has to be used in place of it. The value of the boolean is actually ignored.
+    return true;
+  }
+
+  virtual add_shared_future_t add(const int32_t num1, const int32_t num2) {
+    printf("add(%d,%d)\n", num1, num2);
+
+    // When there is nothing to return yet and we want to defer returning a value, we return
+    // a "promise" in its place. This is a way to signal that we promise to return a value
+    // at a later point.
+    add_shared_promise_t promise;
+
+    // Construct an ASIO timer (we could also fire off a thread here)
+    boost::shared_ptr<boost::asio::deadline_timer> timer(new boost::asio::deadline_timer(io_service_, boost::posix_time::seconds(num1 + num2)));
+
+    // The only reason we pass the timer as the argument is that we want it not to be destroyed
+    timer->async_wait(boost::bind(&CalculatorAsyncHandler::wait_done, this, num1 + num2, promise, timer));
+
+    return promise;
+    // Notice that the signature of the method is add_shared_future_t add(...), i.e. the promise
+    // will be cast to a future. Why does this make sense? In English, a "promise" refers to 
+    // the same thing regardless of one is making a promise or if one is receiving a promise.
+    // In this case, the receiver of the "promise" will take this as a grant that a value will
+    // be returned later, which is what we refer to as a future.
+  }
+
+  virtual void wait_done(const int32_t sum, add_shared_promise_t promise, boost::shared_ptr<boost::asio::deadline_timer> timer) {
+    printf("returning to client\n");
+
+    // The preferred syntax is to write the result straight into the promise by using
+    // the method success() returning a reference to the result value.
+    promise.success() = sum;
+    promise.callback();
+
+    // We could also have simply written promise.callback(sum). For complex types, the
+    // former is slightly more efficient, since the value does not have to be copied.
+    // If sum was a vector of a million elements, this would have mattered.
+
+    printf("done\n");
+    // The timer will fall out of scope now and will be deleted
+  }
+
+  virtual calculate_shared_future_t calculate(const int32_t logid, const Work& w) {
+    calculate_shared_promise_t promise;
+
+    printf("calculate(%d,{%d,%d,%d})\n", logid, w.op, w.num1, w.num2);
+    int32_t val;
+
+    switch (w.op) {
+    case Operation::ADD:
+      val = w.num1 + w.num2;
+      break;
+    case Operation::SUBTRACT:
+      val = w.num1 - w.num2;
+      break;
+    case Operation::MULTIPLY:
+      val = w.num1 * w.num2;
+      break;
+    case Operation::DIVIDE:
+      if (w.num2 == 0) {
+        InvalidOperation io;
+        io.what = w.op;
+        io.why = "Cannot divide by 0";
+
+	// By taking advantage of one of the constructors of the futures, we can
+	// throw any exception by returning the corresponding error object.
+	return calculate_ouch(io);
+      }
+      val = w.num1 / w.num2;
+      break;
+    default:
+      return calculate_failure(std::string("Invalid Operation"));
+    }
+
+    SharedStruct ss;
+    ss.key = logid;
+    char buffer[12];
+    sprintf(buffer, "%d", val);
+    ss.value = buffer;
+
+    log_[logid] = ss;
+
+    printf("val = %d\n", val);
+    
+    // The most fundamental and most verbose way to return a value is:
+    //
+    // calculate_shared_promise_t promise;
+    // promise.success() = vale;
+    // promise.callback();
+    // return promise;
+    //
+    // By taking advantage of the callback(...) shortcut, we can shorten this to:
+    //
+    // calculate_shared_promise_t promise;
+    // promise.callback(val);
+    // return promise;
+    //
+    // However, since we don't want to defer passing a result back, we can use another
+    // shortcut which involves taking advantage of a convenience constructor:
+
+    return val;
+  }
+
+  virtual getStruct_shared_future_t getStruct(const int32_t key) {
+    printf("getStruct(%d)\n", key);
+    return log_[key];
+  }
+
+  virtual void zip() {
+    printf("zip()\n");
+    // Oneway function
+  }
+
+protected:
+  boost::asio::io_service& io_service_;
+  std::map<int32_t, SharedStruct> log_;
+};
+
+int main(int argc, char **argv) {
+  boost::asio::io_service io_service;
+
+  boost::shared_ptr<protocol::TProtocolFactory> protocolFactory(new protocol::TBinaryProtocolFactory());
+  boost::shared_ptr<CalculatorAsyncHandler> handler(new CalculatorAsyncHandler(io_service));
+  boost::shared_ptr<TProcessor> processor(new CalculatorAsyncProcessor(handler));
+
+  boost::shared_ptr<apache::thrift::async::TAsioServer> server(
+							       new apache::thrift::async::TAsioServer(
+												      io_service,
+												      9090,
+												      protocolFactory,
+												      protocolFactory,
+												      processor));
+
+  server->start(); // Nonblocking
+  io_service.run(); // Blocking
+
+  return 0;
+}
diff --git a/third_party/thrift-0.8.0/tutorial/cpp-asio/Makefile b/third_party/thrift-0.8.0/tutorial/cpp-asio/Makefile
new file mode 100644
index 0000000..25f311c
--- /dev/null
+++ b/third_party/thrift-0.8.0/tutorial/cpp-asio/Makefile
@@ -0,0 +1,37 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements. See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership. The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License. You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied. See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+BOOST_DIR = /usr/local/boost/include/boost-1_33_1/
+THRIFT_DIR = /usr/local/include/thrift
+LIB_DIR = /usr/local/lib
+
+DEFINES = -DHAVE_INTTYPES_H -DHAVE_NETINET_IN_H
+
+GEN_SRC = ../gen-cpp/SharedService.cpp ../gen-cpp/shared_types.cpp ../gen-cpp/tutorial_types.cpp ../gen-cpp/Calculator.cpp
+
+default: server client
+
+server: CppServer.cpp
+	g++ -o CppServer -I ../../../ctrlplane/build/include/ -I ../../lib/cpp/src -I${THRIFT_DIR} -I${BOOST_DIR}  -I../gen-cpp -L${LIB_DIR} -L ../../lib/cpp/.libs  ${DEFINES}  CppServer.cpp ${GEN_SRC} -lthrift -lthriftasio -lboost_system
+
+client: CppClient.cpp
+	g++ -o CppClient -I ../../../ctrlplane/build/include -I ../../lib/cpp/src -I${THRIFT_DIR} -I${BOOST_DIR}  -I../gen-cpp -L${LIB_DIR}  -L ../../lib/cpp/.libs ${DEFINES}  CppClient.cpp ${GEN_SRC} -lthrift -lthriftasio -lboost_system
+
+clean:
+	$(RM) -r CppClient CppServer
diff --git a/third_party/thrift-0.8.0/tutorial/cpp/Makefile b/third_party/thrift-0.8.0/tutorial/cpp/Makefile
index e834dee..8115fa9 100644
--- a/third_party/thrift-0.8.0/tutorial/cpp/Makefile
+++ b/third_party/thrift-0.8.0/tutorial/cpp/Makefile
@@ -23,13 +23,15 @@ LIB_DIR = /usr/local/lib
 
 GEN_SRC = ../gen-cpp/SharedService.cpp ../gen-cpp/shared_types.cpp ../gen-cpp/tutorial_types.cpp ../gen-cpp/Calculator.cpp
 
+DEFINES = -DHAVE_INTTYPES_H -DHAVE_NETINET_IN_H
+
 default: server client
 
 server: CppServer.cpp
-	g++ -o CppServer -I${THRIFT_DIR} -I${BOOST_DIR}  -I../gen-cpp -L${LIB_DIR} -lthrift CppServer.cpp ${GEN_SRC}
+	g++ -o CppServer -I${THRIFT_DIR} -I${BOOST_DIR}  -I../gen-cpp -L${LIB_DIR} ${DEFINES} CppServer.cpp ${GEN_SRC} -lthrift
 
 client: CppClient.cpp
-	g++ -o CppClient -I${THRIFT_DIR} -I${BOOST_DIR}  -I../gen-cpp -L${LIB_DIR} -lthrift CppClient.cpp ${GEN_SRC}
+	g++ -o CppClient -I${THRIFT_DIR} -I${BOOST_DIR}  -I../gen-cpp -L${LIB_DIR} ${DEFINES} -lthrift CppClient.cpp ${GEN_SRC} -lthrift
 
 clean:
 	$(RM) -r CppClient CppServer
